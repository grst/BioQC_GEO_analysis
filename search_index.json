[
["index.html", "1 BioQC GEO Analysis 1.1 Introduction 1.2 The Experiment in Brief", " 1 BioQC GEO Analysis Systematically testing the GEO for tissue heterogeneity. Manuscript in preparation 1.1 Introduction Recently we created a software tool, BioQC, that detects tissue heterogeneity in gene expression data and shared it with the community of genome researchers via Bioconductor. The concept of tissue heterogeneity stems from our observations that gene expression data is often compromised by cells originating from other tissues than the target tissue of profiling. Tissue heterogeneity can be caused by physiological or pathological processes, such as immune cell infiltration. Alternatively, they can be caused by technical imperfection to separate complex or nearby tissues or even human errors. Failures in detecting tissue heterogeneity may have profound implications on data interpretation and reproducibility. As bioinformaticians working on drug discovery in the pharma industry, we are convinced that gene expression data available in publicly available databases such as NCBI Gene Expression Omnibus (GEO) or EBI ArrayExpress has great potential to catalyse new therapeutic agents. Disease signatures derived from disease models or patient biopsies, for instance, can be used to assess cellular models used for discovery and to guide compound selection. Molecular phenotypes of compounds, in another example, can be used to validate both efficacy and pre-clinical safety of compounds. Apparently all such applications depend critically on the quality of gene expression data. Several groups have scrutinised publicly available datasets and have identified deleterious factors of data quality such as batch effects, human error, and even data manipulation and faking. However, tissue heterogeneity has not been explicitly addressed so far and there is neither data nor knowledge about its prevalence. To fill this gap, we undertake a systematic investigation of publicly available gene expression datasets. 1.2 The Experiment in Brief BioQC implements a computationally efficient Wilcoxon-Mann-Whitney (WMW) test which is applied to gene expression data on a sample-by-sample basis. Using BioQC, we can efficiently test for the enrichment of certain gene sets, or in this case tissue signatures. These tissue signatures are lists of genes, which are predominantly expressed in a certain tissue. If a signature yields a small p-value in the WMW-test we can therefore conclude that the respective tissue is present in the sample. The authors of BioQC provide a list of more than 150 such signatures for a variety of tissues and cell types. For this study, we independently created and validated tissue signatures based on the GTEx dataset using pygenesig as described in Validating Signatures. We downloaded gene expression data from GEO using GEOquery and obtained the associated metadata from GEOmetadb. Using the metadata, we selected samples as described in sample selection. On all all these samples, we applied BioQC to obtain a p-value for each tissue signature and stored them alongside with the metadata in a database system (DBS). The process of setting up the database is described in Database Design. Finally, we identified contamined samples from the signature scores. If a signature scores high, which is not associated with the annotated tissue, we assume the sample being heterogenous. In section Tissue Migration, we describe how we identify contamined samples and discuss common pattern of tissue heterogenity. "],
["validating-signatures.html", "2 Validating Tissue Signatures 2.1 Data 2.2 Validation", " 2 Validating Tissue Signatures The authors of BioQC have taken three independent approaches to show that their signatures are valid and biologically meaningful. However, they did not break down the predictive performance (i.e. is the signature able to identify its tissue) of each signature with quantitative performance measures. To address this, we independently derived signatures on the GTEx dataset using gini-index and performed both a 10-fold cross validation on the same dataset and a cross-species, cross-platform validation on a different dataset. To this end, we created the python package pygenesig, a framework to create and validate signatures. 2.1 Data GTEx GNF Mouse GeneAtlas V3 https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE10246 platform Affymetrix Mouse Genome 430 2.0 Array (GPL1261) 2.2 Validation GTEx crossvalidation GTEx on mouse TODO: include notebooks in this book. "],
["curating-data.html", "3 Curating Data 3.1 Selecting Samples by Metadata 3.2 Normalize Tissues 3.3 Map tissues to signatures", " 3 Curating Data 3.1 Selecting Samples by Metadata GEOmetadb is a SQLite database containing metadata associated with samples and studies from GEO. This database has proven to be tremendously helpful for selecting samples by tissue and organism. We integrate the database into the study’s DBS and describe how we select samples in detail in Sample selection. 3.2 Normalize Tissues The annotation of tissues is inconsistent within GEO. A “liver” sample can be termed e.g. “liver”, “liver biopsy” or “primary liver”. We therefore need a way to “normalize” the tissue name. We did this manually for the most abundant tissues in this Excel sheet. 3.3 Map tissues to signatures In order to find out which samples are ‘contamined’ by other tissues, we first need to define which signatures we would ‘expect’ in a certain tissue. We therefore manually mapped signatures to the respective tissue type in this Excel sheet. For example, we map the signatures Intestine_Colon_cecum_NR_0.7_3 and Intestine_Colon_NR_0.7_3 to colon. We mapped all normalized tissues from above to the respective signatures, which have at least 500 samples. We mapped tissues with a lower sample count only if they formed a subset of an already mapped tissue (e.g. we mapped prefrontal cortex to brain although having less than 500 samples, because we already mapped signatures to brain.) Moreover, we ran into the issue, that some tissue signatures are not as specific as the annotation in the GEO. We therefore curated so-called tissue sets to combine them into groups. For example, it is hard to distinguish jejunum from colon, but easy to distinguish the two from other tissues. We therefore created a tissue set intestine, which contains both jejunum and colon and references all signatures associated with the two tissues. This information is part of the same Excel sheet. We created a tissue set bioqc_all which maps all tissues to all signatures provided by the authors of BioQC and a high-confidence tissue-set gtex_solid which only maps tissues to signatures that we could validate as high-confidence signatures in Validate Tissue Signatures. "],
["setup-database.html", "4 Setup Database 4.1 Tables explained 4.2 Import GEOmetadb 4.3 Import BioQC data 4.4 Store results", " 4 Setup Database We store meta information for GEO samples and BioQC p-values in an Oracle 11g database. We combine the metadata from GEOmetadb with tables to store signature scores generated with BioQC and manually curated annotations. The following figure shows the database scheme used for the study as entity-relationship (ER) diagram: Figure 4.1: Entitiy relationship diagram of the BioQC database scheme. Click the here for an enlarged version. Greenish tables are imported from GEOmetadb. Yellowish tables are additional tables designed for this study. Three dots (…) indicate columns from GEOmetadb which are omitted in the visualisation because they are not relevant for this study. 4.1 Tables explained 4.1.1 GEOmetadb BIOQC_GSM: from GEOmetadb, meta information for all Samples in GEO BIOQC_GPL: from GEOmetadb, list of all platforms (e.g. different types of microarrays) referenced in GEO. BIOQC_GSE: from GEOmetadb, list of Series (collections of samples) in GEO. 4.1.2 BioQC BIOQC_TISSUES: List of all tissues manually annotated in Normalize Tissues BIOQC_NORMALIZE_TISSUES: Stores the manually curated mapping of the original tissue name to a normalized tissue name. BIOQC_SIGNATURES: Stores gene signatures imported from a GMT file BIOQC_TISSUE_SET: Stores the manually curated mapping of tissues to ‘expected signatures’. BIOQC_RES: Stores the p-value generated with BioQC for each signature in BIOQC_SIGNATURES and each samples in BIOQC_GSM. BIOQC_BIOQC_SUCCESS: List of all studies on which we successfully ran BioQC. This serves as ‘background’ for our analysis. 4.2 Import GEOmetadb First, we need to extract a list of tables: gdb = dbConnect(SQLite(), file.path(DATA_DIR, &quot;geometabase/GEOmetadb.sqlite&quot;)) tables = dbListTables(gdb) writeLines(tables, file(file.path(DATA_DIR, &quot;geometabase/tables.txt&quot;))) Then, we use a conversion script to export the SQL schema and the tables as csv, which can be easily imported into the Oracle DBS. We adjusted the GEOmetadb schema to match Oracle datatypes. Once the tables are imported, we check if all the tables have the same number of rows: # check for consistency for(table in tables) { count.query = sprintf(&quot;select count(*) from %s&quot;, table) count.query.ora = sprintf(&quot;select count(*) from bioqc_%s&quot;, table) print(count.query) expect_equal(dbGetQuery(gdb, count.query)[[1]], dbGetQuery(mydb, tolower(count.query.ora))[[1]]) } 4.2.1 Fix foreign key constraints Unfortunately, foreign key constraints are not enabled in the GEOmetadb SQLite database. It turned out that the GEOmetadb is not entirely consistent when trying to add such constraints in Oracle. We fixed missing parent keys by adding “stub” entries to the tables. The procedure is documented in this SQL script. 4.2.2 Extract Tissue annotation The tissue annotation for each sample is hidden in the characteristics_ch1 column of the BIOQC_GSM table. Since this information is essential for our study, we parsed it into a separate column using a regular expression. The procedure is documented in this SQL script. 4.2.3 Load annotation information To run BioQC, gene symbols need to be annotated in the gene expression matrix. To retrieve gene symbols, we are aware of two feasible possibilities: the Bioconductor annotation packages (listed in GEOmetadb gpl.bioc_package) use the GEO annot_gpl files (“in general available for all GSE that are referenced by a GDS”1) To find out for which GSE in particular the latter option exists, we parsed the directory structure of the GEO ftp server: lftp -c &quot;open ftp://ftp.ncbi.nlm.nih.gov/geo/platforms/ &amp;&amp; find &amp;&amp; exit&quot; &gt; gpl_annot_ftp_tree.txt grep annot.gz gpl_annot_ftp_tree.txt | cut -d&quot;/&quot; -f5 | cut -d&quot;.&quot; -f1 &gt; gpl_annot.txt We add this information the the BIOQC_GPL table as a boolean flag indicating whether the respective platform has an annotation file. # tmp table sql = &quot;create table bioqc_gpl_annot(gpl varchar2(10) primary key, has_annot number(1))&quot; dbSendUpdate(mydb, sql) annot = read.table(&quot;db/data/gpl_annot.txt&quot;) annot = cbind(annot, rep(1, length(annot))) colnames(annot) = c(&quot;1&quot;, &quot;2&quot;) dbAppendDf(&quot;BIOQC_GPL_ANNOT&quot;, annot) # update gpl from tmp table sqlUpdateGpl = &quot; update bioqc_gpl g set has_annot = (select has_annot from bioqc_gpl_annot a where g.gpl = a.gpl)&quot; dbSendUpdate(mydb, sqlUpdateGpl) # drop tmp table sql = &quot;drop table bioqc_gpl_annot&quot; dbSendUpdate(mydb, sql) We compared the two approaches in Sample Selection. 4.3 Import BioQC data We install the BioQC schema using this SQL script. 4.3.1 Signatures Import signatures into the database and create a single, consolidated gmt file. Tissue signature relevant for this study are expr.tissuemark.affy.roche.symbols.gmt and the gtex signatures. # Signatures shipped with BioQC (updated version from 2016-12-08) # download.file(&quot;http://bioinfo.bas.roche.com:8080/apps/gsea/genesets/exp.tissuemark.bioqc.roche.symbols.gmt&quot;, # &quot;data/expr.tissuemark.affy.roche.symbols.gmt&quot;) gmt2db(&quot;data/expr.tissuemark.affy.roche.symbols.gmt&quot;) # control signatures generated from GTEx using *pygenesig* gmt2db(&quot;../gene-set-study/data/gtex/gtex_ngs_0.7_3.gmt&quot;) gmt2db(&quot;../gene-set-study/data/gtex/gtex_ngs_0.85_5.gmt&quot;) # pathway gene sets not relevant for this study gmt2db(&quot;../BioQC_correlated-pathways/go.bp.roche.symbols.gmt.uniq&quot;) gmt2db(&quot;../BioQC_correlated-pathways/MetaBase.downstream.expression.gmt&quot;) gmt2db(&quot;../BioQC_correlated-pathways/path.ronet.roche.symbols.gmt.ascii&quot;) # save imported signatures to consolidated gmt file db2gmt(&quot;results/gmt_all.gmt&quot;) 4.3.2 Tissue Annotation Import the manually curated tissues from Excel into the database. normalized_tissues = data.table(read_excel(&quot;manual_annotation/tissue_annotation.xlsx&quot;, sheet = 1)) tissues = unique(normalized_tissues[!is.na(TISSUE_NORMALIZED),&quot;TISSUE_NORMALIZED&quot;, with=FALSE]) tab_normalized = normalized_tissues[!is.na(TISSUE_NORMALIZED),c(&quot;TISSUE&quot;, &quot;TISSUE_NORMALIZED&quot;), with=FALSE] dbAppendDf(&quot;BIOQC_TISSUES&quot;, tissues) dbAppendDf(&quot;BIOQC_NORMALIZE_TISSUES&quot;, tab_normalized) 4.3.3 Tissue Sets Import the manually curated tissue sets from Excel into the database. bioqc_all = read_excel(&quot;manual_annotation/tissue_annotation.xlsx&quot;, sheet = 3) gtex_all = read_excel(&quot;manual_annotation/tissue_annotation.xlsx&quot;, sheet=4) gtex_solid = read_excel(&quot;manual_annotation/tissue_annotation.xlsx&quot;, sheet=5) signatureset2db(bioqc_all, &quot;bioqc_all&quot;) signatureset2db(gtex_solid, &quot;gtex_solid&quot;) signatureset2db(gtex_all, &quot;gtex_all&quot;) 4.3.4 BioQC results Once we ran the analysis, we manually import the list of samples on which we successfully applied BioQC and the respective p-values into the tables BIOQC_BIOQC_SUCCESS and BIOQC_RES: bioqc_melt_all.uniq.tsv bioqc_success.txt Additionally, we import the study means for each study on each platform: study_stats = read_lines(&quot;/pstore/data/biocomp/users/sturmg/BioQC_GEO_analysis/gse_tissue_annot/study_stats.txt&quot;, skip=1) study_stats_split = lapply(study_stats, function(x) { return(str_split(x, &quot;\\\\s+&quot;)[[1]][1:7]) }) study_stats_df = data.table(do.call(rbind.data.frame, study_stats_split)) for (i in 2:7) { study_stats_df[[i]] = as.numeric(as.character(study_stats_df[[i]])) } study_stats_df = study_stats_df[,GSE:=sapply(as.character(study_stats_df[[1]]), geoIdFromPath)] study_stats_df = study_stats_df[,GPL:=lapply(as.character(study_stats_df[[1]]), gplFromPath)] setcolorder(study_stats_df, c(8, 9, 1:7)) study_stats_df[[3]] = NULL # remove file name colnames(study_stats_df) = as.character(1:ncol(study_stats_df)) # valid colnames for db dbSendUpdate(mydb, &quot;truncate table bioqc_tmp_gse_gpl&quot;) dbAppendDf(&quot;BIOQC_TMP_GSE_GPL&quot;, study_stats_df) dbSendUpdate(mydb, &quot;update bioqc_gse_gpl a set (study_min, study_25, study_median, study_mean, study_75, study_max) = (select study_min, study_25, study_median, study_mean, study_75, study_max from bioqc_tmp_gse_gpl b where a.gse = b.gse and (a.gpl = b.gpl or b.gpl is NULL))&quot;) 4.4 Store results We do not only use the database as pure data storage, but also as data analysis engine, harvesting the power of SQL. (See sections sample selection and contamination analysis). We save intermediate results of time-consuming queries in so-called materialized views, which are pysical snapshots of a query’s result. https://bioconductor.org/packages/release/bioc/manuals/GEOquery/man/GEOquery.pdf↩ "],
["sample-selection.html", "5 Sample Selection and processing 5.1 Sample Preselection 5.2 Sample Processing with BioQC 5.3 Sample Post-selection", " 5 Sample Selection and processing 5.1 Sample Preselection Here, we document the sample selection process before running BioQC. 5.1.1 Required annotation A sample is usable for this study, if the gene symbos are annotated (requirement to run BioQC) the tissue of origin is annotated (requirment to draw conclusions about contamination) We consider two approaches for annotating gene symbols: Using the Bioconductor AnnotationDbi package. The GEOmetadb provides a mapping of the GPL identifier to these packages. Using the annotGPL=TRUE option of GEOquery’s getGEO. This requires an annotation file being available for the respective platform. We retrieved a list of the available annoataion files in an earlier step. We compare the two methods with respect to the amount of usable samples that we can get. First we need to run the sql-script annotation_stats which will create views summarizing the amount of usable samples. From these views, we can calculate a Venn diagram: The getGEO method appears to be the more powerful method. Ideal would be a combination of the two, however, for the sake of simplicity, we stick to getGEO, loosing 499 studies (35602 samples). This leaves us with the following filtering result: comment GSM GSE total 1945417 73719 tissue annotated 760798 24267 annotation file available 768346 31579 tissue and annotation file 275206 9632 5.1.2 Export list of samples We store the respective gse identifiers in results/gse_lists/gse_tissue_annotation.txt: sqlGse = &quot; select distinct gse from ( select * from bioqc_studies_has_tissue intersect select * from bioqc_studies_has_annot) u&quot; gse = dbGetQuery(mydb, sqlGse) writeLines(gse$GSE, file(gse.file)) 5.2 Sample Processing with BioQC The following processes are ressource intensive, therefore we execute them on a high performance cluster (HPC). We use chunksub to distribute the list of sample ids to the workers. This involves four major steps which are also documented in the project’s Makefile. We download the studies with GEOquery and store them as R ExpressionSet using the R script geo_to_eset.R. For some series, the download is not successful. We annotated human orthologous genes for all studies using ribiosAnnotation in annotate_eset.R. This is necessary as the tissue signatures are built on a human dataset. The annotation failes for species which are not in the ribios database. We run BioQC on these studies use run_bioqc.R. Finally, we prefilter BioQC’s results for having a p-value &lt; 0.05 and import them into the database. 5.3 Sample Post-selection The failures during download and annotation reduce the number of samples available to our study. sql_select = &quot; select /*+ USE_HASH(bs, bgg) parallel(16) */ count(distinct bg.gsm) as GSM , count(distinct bgg.gse) as GSE&quot; sql_from = &quot; from bioqc_bioqc_success bs join bioqc_gsm bg on bg.gsm = bs.gsm join bioqc_gse_gsm bgg on bgg.gsm = bs.gsm &quot; sql_where = &quot;&quot; res = dbGetQuery(mydb, str_c(sql_select, sql_from, sql_where, sep=&quot;\\n&quot;)) kable(res) GSM GSE 253210 8083 5.3.1 Excluding multi-channel microarrays Multi channel microarrays date back to the early age of gene expression studies. They don’t provide absolute gene expression data and are not meaningful outside their experimental context. We therefore exclude these experiments: sql_select2 = sql_select sql_from2 = sql_from sql_where2 = str_c(sql_where, &quot;where channel_count = 1&quot;, sep=&quot;\\n&quot;) res = dbGetQuery(mydb, str_c(sql_select2, sql_from2, sql_where2, sep=&quot;\\n&quot;)) kable(res) GSM GSE 235237 7561 5.3.2 Exclude non-mapped tissues We exclude samples that have a tissue annotated, but it is not mapped to a normalized tissue. sql_select3 = sql_select2 sql_from3 = str_c(sql_from2, &quot; join bioqc_normalize_tissues bnt on bnt.tissue_orig = lower(bg.tissue_orig)&quot;, sep=&quot;\\n&quot;) sql_where3 = sql_where2 res = dbGetQuery(mydb, str_c(sql_select3, sql_from3, sql_where3, sep=&quot;\\n&quot;)) kable(res) GSM GSE 135670 3770 5.3.3 Select organisms We were interested in the organism distribution. sql_select4 = str_c(sql_select3, &quot;, bg.organism_ch1&quot;, sep=&quot;\\n&quot;) sql_from4 = sql_from3 sql_where4 = sql_where3 res = dbGetQuery(mydb, str_c(sql_select4, sql_from4, sql_where4, &quot; group by organism_ch1 order by gsm desc&quot;, sep=&quot;\\n&quot;)) kable(res) GSM GSE ORGANISM_CH1 65769 1201 Homo sapiens 38096 2267 Mus musculus 29909 278 Rattus norvegicus 1082 24 Macaca mulatta 259 7 Macaca fascicularis 202 2 Mus musculus musculus x M. m. domesticus 80 2 Cercocebus atys 57 1 Oryctolagus cuniculus 36 1 Chlorocebus aethiops 32 3 Mus musculus domesticus 25 1 Pan troglodytes 23 1 Papio cynocephalus 19 1 Mus spretus 18 1 Capra hircus 16 1 Phodopus sungorus 12 1 Papio hamadryas 12 1 Mus musculus musculus x M. m. castaneus 8 1 Macaca nemestrina 6 1 Mus musculus musculus 6 1 Mus musculus castaneus 3 1 Mus sp. Results suggest that it makes sense to limit the analysis to the three main organisms: H. sapiens, M. musculus, R. norvegicus. This makes also sense as these species are closesly related and therefore the signatures are more likely to translate within these species. We are left with the following amount of samples: sql_select5 = sql_select3 sql_from5 = sql_from4 sql_where5 = str_c(sql_where4, &quot; and organism_ch1 in (&#39;Homo sapiens&#39;, &#39;Mus musculus&#39;, &#39;Rattus norvegicus&#39;)&quot;, sep=&quot;\\n&quot;) res = dbGetQuery(mydb, str_c(sql_select5, sql_from5, sql_where5, sep=&quot;\\n&quot;)) kable(res) GSM GSE 133774 3727 5.3.4 Exclude normalized studies sql = &quot; select study_median from bioqc_gse_gpl where study_median is not null&quot; res = dbGetQuery(mydb, sql) sm = res$STUDY_MEDIAN hist(sm[sm &gt; -5 &amp; sm &lt; 30], breaks=seq(-5, 30, .2)) We observe three peaks, the first and second have been normalized in some way. We focus on the studies with a median between 3 and 9. TODO do proper fit of distributions and rationale based on standard deviation sql_select6 = sql_select5 sql_from6 = str_c(sql_from5, &quot; join bioqc_gse_gpl bgl on bgg.gse = bgl.gse and bg.gpl = bgl.gpl&quot;, sep=&quot;\\n&quot;) sql_where6 = str_c(sql_where5, &quot; and study_median between 3 and 9&quot;, sep=&quot;\\n&quot;) res = dbGetQuery(mydb, str_c(sql_select6, sql_from6, sql_where6, sep=&quot;\\n&quot;)) kable(res) GSM GSE 82933 1837 This is the ‘background’ of samples on which we test for tissue contamination. We store the selected samples alongside with meta information required for the analysis in the materialized view BIOQC_SELECTED_SAMPLES in our DBS. Here is the SQL script generating the materialized view. 5.3.5 Tissue abundance The following table shows how many samples are available for each tissue: sqlTissue = &quot; select /*+ parallel(16) */ tissue, count(distinct gsm) as samples from bioqc_selected_samples group by tissue order by samples desc&quot; resTissue = dbGetQuery(mydb, sqlTissue) kable(resTissue) TISSUE SAMPLES blood 33055 liver 27029 lung 9732 kidney 7588 bone marrow 6581 brain 5824 heart 4819 breast tumor 4238 spleen 3518 adipose 2857 skeletal muscle 2474 skin 2326 hippocampus 2059 colon 1954 hepatocyte 1874 tumor 1679 white blood cells 1551 lymph node 1335 breast 1227 cerebellum 1200 testis 1131 pbmc 936 frontal cortex 805 pancreas 770 placenta 766 retina 714 pancreatic islets 647 thymus 642 ovary 570 prostate 523 mammary gland 479 hypothalamus 470 jejunum 456 prefrontal cortex 410 cortex 336 embryo 290 uterus 246 cervix 148 stomach 139 salivary gland 133 bladder 123 ventral midbrain 78 eye 69 adrenal gland 67 monocyte 59 neuroblastoma 45 plasma 9 "],
["contamination-analysis.html", "6 Analyse Contamination 6.1 Input Tables 6.2 Processing Steps explained", " 6 Analyse Contamination The heartpiece of the study is this sql script which identifies heterogenous samples. In this section we will go through the different analysis steps performed in the script. 6.1 Input Tables BIOQC_SELECTED_SAMPLES: the samples resulting from the selection process including metadata BIOQC_TISSUE_SET: the manual mapping of tissues to signatures (“expected signatures”) BIOQC_RES: the p-values for each sample and signature (pre-filtered for having a p-value &lt; 0.05) 6.2 Processing Steps explained 6.2.1 BIOQC_SELECTED_SAMPLES_TSET We join BIOQC_SELECTED_SAMPLES on BIOQC_TISSUE_SET to attach the tissue group and the respective signatures to each sample. Example: The table rows for the colon sample GSM1234 could look like: GSM TISSUE TISSUE_SET TGROUP EXP_SIGNATURE EXP_SIGNATURE_NAME GSM1234 colon gtex_all colon 543 Colon GSM1234 colon gtex_solid intestine 543 Colon GSM1234 colon gtex_solid intestine 544 Jejunum 6.2.2 BIOQC_RES_TSET We join the BioQC results (pvalue for each signature and sample) from BIOQC_RES with BIOQC_TISSUE_SET to map the signatures back to their tissue group. Example: For a result GSM SIGNATURE PVALUE GSM1234 544 1e-10 GSM1234 543 1e-5 the table rows could look like GSM FOUND_SIG PVALUE FOUND_SIG_NAME FOUND_TGROUP TISSUE_SET GSM1234 544 1e-10 Jejunum jejunum gtex_all GSM1234 544 1e-10 Jejunum intestine gtex_solid GSM1234 543 1e-5 Colon colon gtex_all GSM1234 543 1e-5 Colon intestine gtex_solid 6.2.3 BIOQC_TISSUE_ENRICHMENT We now match the found onto the expected tissue groups by joining BIOQC_SELECTED_SAMPES_TSET with BIOQC_RES_TSET on GSM and TISSUE_SET. We calculate the Enrichment Ratio as \\(\\log_{10}(p_{expected\\_sig} / p_{found\\_sig})\\). For the above example tables, we would get: GSM TISSUE TISSUE_SET TGROUP EXP_SIGNATURE EXP_SIGNATURE_NAME FOUND_SIG FOUND_SIG_NAME ENRICHMENT_RATIO GSM1234 colon gtex_all colon 543 Colon 543 Colon 0.0 GSM1234 colon gtex_all colon 543 Colon 544 Jejunum 5.0 ... We filter out rows where the found signature is in the list of expected sigantures for the respective tissue group: GSM TISSUE TISSUE_SET TGROUP EXP_SIGNATURE EXP_SIGNATURE_NAME FOUND_SIG FOUND_SIG_NAME ENRICHMENT_RATIO GSM1234 colon gtex_all colon 543 Colon 544 Jejunum 5.0 ... 6.2.4 BIOQC_TISSUE_ENRICHMENT2 combine expected signature by taking the minimal enrichment ratio for each expected signature. Example: GSM TISSUE TGROUP EXPECTED FOUND ENRICHMENT_RATIO GSM888 jejunum intestine colon liver_fetal 12 GSM888 jejunum intestine colon liver 8 GSM888 jejunum intestine jejunum liver_fetal 5 GSM888 jejunum intestine jejunum liver 4 will be combined into GSM TGROUP EXPECTED FOUND ENRICHMENT_RATIO RANK GSM888 intestine liver_fetal 5 1 GSM888 intestine liver 4 1 if multiple infiltrating tissues are found, a rank is calculated. 6.2.5 BIOQC_CONTAM_STATS Add year, country and organism to each sample from BIOQC_TISSUE_ENRICHMENT2. 6.2.6 BIOQC_TISSUE_MIGRATION Add origin and destination tissue groups for each sample by mapping the found signatures back to tissue groups. Example: GSM TISSUE_SET ORIGIN FOUND_SIG FOUND_SIG_NAME ENRICHMENT_RATIO DESTINATION GSM1234 gtex_all colon 544 Jejunum 5 jejunum "],
["tissue-migration.html", "7 Tissue Migration", " 7 Tissue Migration Now, detect samples we defined as contamined: * highly siginificant BioQC scores (min score per sample &gt;6) * signature outside ‘expected’ signature that is at least 6 higher than the highest score in expected signatures. * (outlier in study) We can find contamined studies with SQL only. To speed up things, we create a temporary table (rather a materialized view, but that’s not available on our old postgres server) filtering for samples, where a non-expected signature exceeds all expected signatures by a certain threshold (BioQC score &gt; 6, aka. ‘enrichment-ratio’). This table is created in db/queries/mk-extended_bioqc_res_table2.sql. We create a view contamined_samples that contains all contamined samples in db/queries/get_contamined_samples.sql. Second, we retrieve the information we need for the migration chart from that temporary table. query = &quot; select origin , destination , count(gsm) as \\&quot;count\\&quot; from bioqc_tissue_migration where enrichment_ratio &gt; 4 and rk = 1 and tissue_set = &#39;bioqc_all&#39; group by origin, destination order by origin, destination&quot; migration = dbGetQuery(mydb, query) set.seed(42) col = rand_color(length(unique(migration$ORIGIN))) chordDiagram(migration, grid.col=col, annotationTrack=&quot;grid&quot;, preAllocateTracks=1) circos.trackPlotRegion(track.index=1, panel.fun = function(x, y) { xlim = get.cell.meta.data(&quot;xlim&quot;) ylim = get.cell.meta.data(&quot;ylim&quot;) sector.name = get.cell.meta.data(&quot;sector.index&quot;) circos.text(mean(xlim), ylim[1] + .1, sector.name, facing = &quot;clockwise&quot;, niceFacing = TRUE, adj = c(0, 0.5)) circos.axis(h = &quot;top&quot;, labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 2) }, bg.border = NA) chordDiagram(migration[migration$ORIGIN != &#39;blood&#39; &amp; migration$DESTINATION!=&#39;blood&#39;,]) Contamination in total: We can also compose statistics about the origin of samples By time byYear = &quot; with contam_stats as ( select bcs.* , case when enrichment_ratio &gt; 4 then 1 else null end as is_contam from bioqc_contam_stats bcs ) select year , tgroup , count(gsm) as total , count(is_contam) as contamined , count(is_contam)/cast(count(gsm) as float) as ratio from contam_stats where tissue_set = &#39;gtex_solid&#39; group by year, tgroup order by ratio desc &quot; year = dbGetQuery(mydb, byYear) ggplot(data=year, aes(x=YEAR, y=RATIO)) + stat_summary(fun.y=&quot;mean&quot;, geom=&quot;bar&quot;) By country (that’s nice figures, but it’s not very representative… tissue-bias, statistical significance, …) byCountry = &quot; with contam_stats as ( select bcs.* , case when enrichment_ratio &gt; 4 then 1 else null end as is_contam from bioqc_contam_stats bcs ) select country , tgroup , count(gsm) as total , count(is_contam) as contamined , count(is_contam)/cast(count(gsm) as float) as ratio from contam_stats where tissue_set = &#39;gtex_solid&#39; group by country, tgroup order by ratio desc &quot; country = dbGetQuery(mydb, byCountry) country.2 = country[country$TGROUP == &#39;liver&#39;,] #country.2 = ddply(country[country$total &gt; 2000,], ~country,summarise,ratio=mean(ratio)) spdf &lt;- joinCountryData2Map(country.2, joinCode=&quot;NAME&quot;, nameJoinColumn=&quot;COUNTRY&quot;) mapCountryData(spdf, nameColumnToPlot=&quot;RATIO&quot;, catMethod=&quot;fixedWidth&quot;) By organism byOrganism = &quot; with contam_stats as ( select bcs.* , case when enrichment_ratio &gt; 4 then 1 else null end as is_contam from bioqc_contam_stats bcs ) select organism , tgroup , count(gsm) as total , count(is_contam) as contamined , count(is_contam)/cast(count(gsm) as float) as ratio from contam_stats where tissue_set = &#39;gtex_solid&#39; group by organism, tgroup order by ratio desc &quot; organism = dbGetQuery(mydb, byOrganism) tissues = c(&quot;blood&quot;, &quot;brain&quot;, &quot;kidney&quot;, &quot;liver&quot;) organism.2 = organism[organism$TGROUP %in% tissues, ] #ggplot(data=organism.2, aes(x=ORGANISM, y=RATIO)) + stat_summary(fun.y=&quot;mean&quot;, geom=&quot;bar&quot;) ggplot(data=organism.2, aes(x=ORGANISM, y=RATIO)) + geom_boxplot() + geom_point(aes(color=TGROUP)) "]
]
