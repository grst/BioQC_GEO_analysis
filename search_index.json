[
["index.html", "1 BioQC GEO Analysis 1.1 Introduction 1.2 BioQC 1.3 Signatures 1.4 The Experiment in Brief", " 1 BioQC GEO Analysis Systematically testing the GEO for tissue heterogeneity. Manuscript in preparation 1.1 Introduction Recently we created a software tool, BioQC, that detects tissue heterogeneity in gene expression data and shared it with the community of genome researchers via Bioconductor. The concept of tissue heterogeneity stems from our observations that gene expression data is often compromised by cells originating from other tissues than the target tissue of profiling. Tissue heterogeneity can be caused by physiological or pathological processes, such as immune cell infiltration. Alternatively, they can be caused by technical imperfection to separate complex or nearby tissues or even human errors. Failures in detecting tissue heterogeneity may have profound implications on data interpretation and reproducibility. As bioinformaticians working on drug discovery in the pharma industry, we are convinced that gene expression data available in publicly available databases such as NCBI Gene Expression Omnibus (GEO) or EBI ArrayExpress has great potential to catalyse new therapeutic agents. Disease signatures derived from disease models or patient biopsies, for instance, can be used to assess cellular models used for discovery and to guide compound selection. Molecular phenotypes of compounds, in another example, can be used to validate both efficacy and pre-clinical safety of compounds. Apparently all such applications depend critically on the quality of gene expression data. Several groups have scrutinised publicly available datasets and have identified deleterious factors of data quality such as batch effects, human error, and even data manipulation and faking. However, tissue heterogeneity has not been explicitly addressed so far and there is neither data nor knowledge about its prevalence. To fill this gap, we undertake a systematic investigation of publicly available gene expression datasets. We first explain how we curated samples from GEO and mapped the tissue annotation to signatures. Second, we show how we use pygenesig to independently create and validate signatures. Third, we provide technical information about our data storage stragegy using a DBS. 1.2 BioQC BioQC implements a computationally efficient Wilcoxon-Mann-Whitney (WMW) test. 1.3 Signatures Tissue signatures are essentially a list of genes which are enriched in a certain tissue. 1.4 The Experiment in Brief We take all samples from GEO which have the required annotation. We run BioQC on each of the samples. We compare the tissue predicted by BioQC with the annotated tissue and call a sample ‘contamined’ if the prediction does not match the annotation. "],
["curating-data.html", "2 Curating Data 2.1 Selecting Samples by Metadata 2.2 Normalize Tissues 2.3 Map tissues to signatures", " 2 Curating Data 2.1 Selecting Samples by Metadata GEOmetadb is a SQLite database containing metadata associated with samples and studies from GEO. This database has proven to be tremendously helpful for selecting samples by tissue and organism. We integrate the database into the study’s DBS and describe how we select samples in detail in Sample selection. 2.2 Normalize Tissues The annotation of tissues is inconsistent within GEO. A “liver” sample can be termed e.g. “liver”, “liver biopsy” or “primary liver”. We therefore need a way to “normalize” the tissue name. We did this manually for the most abundant tissues in this Excel sheet. 2.3 Map tissues to signatures In order to find out which samples are ‘contamined’ by other tissues, we first need to define which signatures we would ‘expect’ in a certain tissue. We therefore manually mapped signatures to the respective tissue type in this Excel sheet. For example, we map the signatures Intestine_Colon_cecum_NR_0.7_3 and Intestine_Colon_NR_0.7_3 to colon. We mapped all normalized tissues from above to the respective signatures, which have at least 500 samples. We mapped tissues with a lower sample count only if they formed a subset of an already mapped tissue (e.g. we mapped prefrontal cortex to brain although having less than 500 samples, because we already mapped signatures to brain.) Moreover, we ran into the issue, that some tissue signatures are not as specific as the annotation in the GEO. We therefore curated so-called tissue sets. For example, it is hard to distinguish jejunum from colon, but easy to distinguish the two from other tissues. We therefore created a tissue set intestine, which contains both jejunum and colon and references all signatures associated with the two tissues. This information is part of the same Excel sheet and combine them into groups. "],
["validating-tissue-signatures.html", "3 Validating Tissue Signatures 3.1 Data", " 3 Validating Tissue Signatures The authors of BioQC have taken three independent approaches to show that their signatures are valid and biologically meaningful. However, they did not break down the predictive performance (i.e. is the signature able to identify its tissue) of each signature with quantitative performance measures. To address this, we independently derived signatures on the GTEx dataset using gini-index and performed both a 10-fold cross validation on the same dataset and a cross-species, cross-platform validation on a different dataset. To this end, we created the python package pygenesig, a framework to create and validate signatures. 3.1 Data GTEx GNF Mouse GeneAtlas V3 https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE10246 platform Affymetrix Mouse Genome 430 2.0 Array (GPL1261) "],
["setup-database.html", "4 Setup Database 4.1 Tables explained 4.2 Import GEOmetadb 4.3 Import BioQC data", " 4 Setup Database We store meta information for GEO samples and BioQC p-values in an Oracle 11g database. We combine the metadata from GEOmetadb with tables to store signature scores generated with BioQC and manually curated annotations. GEOmetadb is an SQLite database containing metadata associated with samples and studies from GEO. Figure 4.1: Entitiy relationship diagram of the BioQC database scheme. Click the here for an enlarged version. Greenish tables are imported from GEOmetadb. Yellowish tables are additional tables designed for this study. Three dots (…) indicate columns from GEOmetadb which are omitted in the visualisation because they are not relevant for this study. 4.1 Tables explained 4.1.1 GEOmetadb BIOQC_GSM: from GEOmetadb, meta information for all Samples in GEO BIOQC_GPL: from GEOmetadb, list of all platforms (e.g. different types of microarrays) referenced in GEO. BIOQC_GSE: from GEOmetadb, list of Series (collections of samples) in GEO. 4.1.2 Tissue Annotation The annotation of tissues is inconsistent within GEO. A “liver” sample can be termed e.g. “liver”, “liver biopsy” or “primary liver”. We therefore need a way to “normalize” the tissue name. We did this manually for the most abundant tissues in this Excel sheet which is then imported into the BIOQC_NORMALIZE_TISSUES table. BIOQC_TISSUES is simply a unique list of all curated tissues. 4.1.3 Signatures Signatures are essentially a list of genes, which are over-represented in a certain tissue, cell type, pathway, etc. A common way to save such signatures is the GMT file format. These GMT files can be imported into BIOQC_SIGNATURES. 4.1.4 Expected Signatures which we imported into BIOQC_TISSUE_SET. 4.1.5 Results Our analysis creates a p-value for each sample in BIOQC_GSM and each signature in BIOQC_SIGNATURES. These p-values are stored in BIOQC_RES. 4.2 Import GEOmetadb First, we need to extract a list of tables: gdb = dbConnect(SQLite(), file.path(DATA_DIR, &quot;geometabase/GEOmetadb.sqlite&quot;)) tables = dbListTables(gdb) writeLines(tables, file(file.path(DATA_DIR, &quot;geometabase/tables.txt&quot;))) Then, we use a conversion script to export the SQL schema and the tables as csv, which can be easily imported into the Oracle DBS. We adjusted the GEOmetadb schema to match Oracle datatypes. Once the tables are imported, we check if all the tables have the same number of rows: # check for consistency for(table in tables) { count.query = sprintf(&quot;select count(*) from %s&quot;, table) count.query.ora = sprintf(&quot;select count(*) from bioqc_%s&quot;, table) print(count.query) expect_equal(dbGetQuery(gdb, count.query)[[1]], dbGetQuery(mydb, tolower(count.query.ora))[[1]]) } 4.2.1 Fix foreign key constraints Unfortunately, foreign key constraints are not enabled in the GEOmetadb SQLite database. It turned out that the GEOmetadb is not entirely consistent when trying to add such constraints in Oracle. We fixed missing parent keys by adding “stub” entries to the tables. The procedure is documented in this SQL script. 4.2.2 Extract Tissue annotation The tissue annotation for each sample is hidden in the characteristics_ch1 column of the BIOQC_GSM table. Since this information is essential for our study, we parsed it into a separate column using a regular expression. The procedure is documented in this SQL script. 4.2.3 Load annotation information To run BioQC, gene symbols need to be annotated in the gene expression matrix. To retrieve gene symbols, we are aware of two feasible possibilities: the Bioconductor annotation packages (listed in GEOmetadb gpl.bioc_package) use the GEO annot_gpl files (“in general available for all GSE that are referenced by a GDS”1) To find out for which GSE in particular the latter option exists, we parsed the directory structure of the GEO ftp server: lftp -c &quot;open ftp://ftp.ncbi.nlm.nih.gov/geo/platforms/ &amp;&amp; find &amp;&amp; exit&quot; &gt; gpl_annot_ftp_tree.txt grep annot.gz gpl_annot_ftp_tree.txt | cut -d&quot;/&quot; -f5 | cut -d&quot;.&quot; -f1 &gt; gpl_annot.txt We add this information the the BIOQC_GPL table as a boolean flag indicating whether the respective platform has an annotation file. # tmp table sql = &quot;create table bioqc_gpl_annot(gpl varchar2(10) primary key, has_annot number(1))&quot; dbSendUpdate(mydb, sql) annot = read.table(&quot;db/data/gpl_annot.txt&quot;) annot = cbind(annot, rep(1, length(annot))) colnames(annot) = c(&quot;1&quot;, &quot;2&quot;) dbAppendDf(&quot;BIOQC_GPL_ANNOT&quot;, annot) # update gpl from tmp table sqlUpdateGpl = &quot; update bioqc_gpl g set has_annot = (select has_annot from bioqc_gpl_annot a where g.gpl = a.gpl)&quot; dbSendUpdate(mydb, sqlUpdateGpl) # drop tmp table sql = &quot;drop table bioqc_gpl_annot&quot; dbSendUpdate(mydb, sql) We compared the two approaches in Sample Selection. 4.3 Import BioQC data We install the BioQC schema using this SQL script. 4.3.1 Signatures Import signatures into the database and create a single, consolidated gmt file. Tissue signature relevant for this study are expr.tissuemark.affy.roche.symbols.gmt and the gtex signatures. # Signatures shipped with BioQC (updated version from 2016-12-08) # download.file(&quot;http://bioinfo.bas.roche.com:8080/apps/gsea/genesets/exp.tissuemark.bioqc.roche.symbols.gmt&quot;, # &quot;data/expr.tissuemark.affy.roche.symbols.gmt&quot;) gmt2db(&quot;data/expr.tissuemark.affy.roche.symbols.gmt&quot;) # control signatures generated from GTEx using *pygenesig* gmt2db(&quot;../gene-set-study/data/gtex/gtex_ngs_0.7_3.gmt&quot;) gmt2db(&quot;../gene-set-study/data/gtex/gtex_ngs_0.85_5.gmt&quot;) # pathway gene sets not relevant for this study gmt2db(&quot;../BioQC_correlated-pathways/go.bp.roche.symbols.gmt.uniq&quot;) gmt2db(&quot;../BioQC_correlated-pathways/MetaBase.downstream.expression.gmt&quot;) gmt2db(&quot;../BioQC_correlated-pathways/path.ronet.roche.symbols.gmt.ascii&quot;) # save imported signatures to consolidated gmt file db2gmt(&quot;results/gmt_all.gmt&quot;) 4.3.2 Tissue Annotation Import the manually curated tissues from Excel into the database. normalized_tissues = data.table(read_excel(&quot;manual_annotation/tissue_annotation.xlsx&quot;, sheet = 1)) tissues = unique(normalized_tissues[!is.na(TISSUE_NORMALIZED),&quot;TISSUE_NORMALIZED&quot;, with=FALSE]) tab_normalized = normalized_tissues[!is.na(TISSUE_NORMALIZED),c(&quot;TISSUE&quot;, &quot;TISSUE_NORMALIZED&quot;), with=FALSE] dbAppendDf(&quot;BIOQC_TISSUES&quot;, tissues) dbAppendDf(&quot;BIOQC_NORMALIZE_TISSUES&quot;, tab_normalized) 4.3.3 Tissue Sets Import the manually curated tissue sets from Excel into the database. bioqc_all = read_excel(&quot;manual_annotation/tissue_annotation.xlsx&quot;, sheet = 3) gtex_all = read_excel(&quot;manual_annotation/tissue_annotation.xlsx&quot;, sheet=4) gtex_solid = read_excel(&quot;manual_annotation/tissue_annotation.xlsx&quot;, sheet=5) signatureset2db(bioqc_all, &quot;bioqc_all&quot;) signatureset2db(gtex_solid, &quot;gtex_solid&quot;) signatureset2db(gtex_all, &quot;gtex_all&quot;) https://bioconductor.org/packages/release/bioc/manuals/GEOquery/man/GEOquery.pdf↩ "],
["sample-selection.html", "5 Sample Selection and processing 5.1 Sample Preselection 5.2 Sample Processing with BioQC 5.3 Update database 5.4 Sample Post-selection", " 5 Sample Selection and processing 5.1 Sample Preselection Here, we document the sample selection process before running BioQC. 5.1.1 Required annotation A sample is usable for this study, if the gene symbos are annotated (requirement to run BioQC) the tissue of origin is annotated (requirment to draw conclusions about contamination) We consider two approaches for annotating gene symbols: Using the Bioconductor AnnotationDbi package. The GEOmetadb provides a mapping of the GPL identifier to these packages. Using the annotGPL=TRUE option of GEOquery’s getGEO. This requires an annotation file being available for the respective platform. We retrieved a list of the available annoataion files in an earlier step. We compare the two methods with respect to the amount of usable samples that we can get. First we need to run the sql-script annotation_stats which will create views summarizing the amount of usable samples. From these views, we can calculate a Venn diagram: The getGEO method appears to be the more powerful method. Ideal would be a combination of the two, however, for the sake of simplicity, we stick to getGEO, loosing 499 studies (35602 samples). This leaves us with the following filtering result: comment GSM GSE total 1945417 73719 tissue annotated 760798 24267 annotation file available 768346 31579 tissue and annotation file 275206 9632 5.1.2 Export list of samples We store the respective gse identifiers in results/gse_lists/gse_tissue_annotation.txt: sqlGse = &quot; select distinct gse from ( select * from bioqc_studies_has_tissue intersect select * from bioqc_studies_has_annot) u&quot; gse = dbGetQuery(mydb, sqlGse) writeLines(gse$GSE, file(gse.file)) 5.2 Sample Processing with BioQC The following processes are ressource intensive, therefore we execute them on a high performance cluster (HPC). We use chunksub to distribute the list of sample ids to the workers. This involves four major steps which are also documented in the project’s Makefile. We download the studies with GEOquery and store them as R ExpressionSet using the R script geo_to_eset.R. For some series, the download is not successful. We annotated human orthologous genes for all studies using ribiosAnnotation in annotate_eset.R. This is necessary as the tissue signatures are built on a human dataset. The annotation failes for species which are not in the ribios database. We run BioQC on these studies use run_bioqc.R. Finally, we prefilter BioQC’s results for having a p-value &lt; 0.05 and import them into the database. 5.3 Update database we aggregate the bioqc results and import them manually in the DBS. we collate all samples on which we successfully ran BioQC. This is our Background. 5.4 Sample Post-selection The failures during download and annotation reduce the number of samples available to our study. sql_select = &quot; select /*+ USE_HASH(bs, bgg) parallel(16) */ count(distinct bg.gsm) as GSM , count(distinct bgg.gse) as GSE&quot; sql_from = &quot; from bioqc_bioqc_success bs join bioqc_gsm bg on bg.gsm = bs.gsm left outer join bioqc_gse_gsm bgg on bgg.gsm = bs.gsm &quot; sql_where = &quot;&quot; res = dbGetQuery(mydb, str_c(sql_select, sql_from, sql_where, sep=&quot;\\n&quot;)) kable(res) GSM GSE 253714 8083 5.4.1 Excluding multi-channel microarrays Multi channel microarrays date back to the early age of gene expression studies. They don’t provide absolute gene expression data and are not meaningful outside their experimental context. We therefore exclude these experiments: sql_select2 = sql_select sql_from2 = sql_from sql_where2 = str_c(sql_where, &quot;where channel_count = 1&quot;, sep=&quot;\\n&quot;) res = dbGetQuery(mydb, str_c(sql_select2, sql_from2, sql_where2, sep=&quot;\\n&quot;)) kable(res) GSM GSE 235741 7561 5.4.2 Exclude non-mapped tissues We exclude samples that have a tissue annotated, but it is not mapped to a normalized tissue. sql_select3 = sql_select2 sql_from3 = str_c(sql_from2, &quot; join bioqc_normalize_tissues bnt on bnt.tissue_orig = lower(bg.tissue_orig)&quot;, sep=&quot;\\n&quot;) sql_where3 = sql_where2 res = dbGetQuery(mydb, str_c(sql_select3, sql_from3, sql_where3, sep=&quot;\\n&quot;)) kable(res) GSM GSE 135877 3770 5.4.3 Select organisms We were interested in the organism distribution. sql_select4 = str_c(sql_select3, &quot;, bg.organism_ch1&quot;, sep=&quot;\\n&quot;) sql_from4 = sql_from3 sql_where4 = sql_where3 res = dbGetQuery(mydb, str_c(sql_select4, sql_from4, sql_where4, &quot; group by organism_ch1 order by gsm desc&quot;, sep=&quot;\\n&quot;)) kable(res) GSM GSE ORGANISM_CH1 65944 1201 Homo sapiens 38128 2267 Mus musculus 29909 278 Rattus norvegicus 1082 24 Macaca mulatta 259 7 Macaca fascicularis 202 2 Mus musculus musculus x M. m. domesticus 80 2 Cercocebus atys 57 1 Oryctolagus cuniculus 36 1 Chlorocebus aethiops 32 3 Mus musculus domesticus 25 1 Pan troglodytes 23 1 Papio cynocephalus 19 1 Mus spretus 18 1 Capra hircus 16 1 Phodopus sungorus 12 1 Mus musculus musculus x M. m. castaneus 12 1 Papio hamadryas 8 1 Macaca nemestrina 6 1 Mus musculus musculus 6 1 Mus musculus castaneus 3 1 Mus sp. Results suggest that it makes sense to limit the analysis to the three main organisms: H. sapiens, M. musculus, R. norvegicus. This makes also sense as these species are closesly related and therefore the signatures are more likely to translate within these species. We are left with the following amount of samples: sql_select5 = sql_select3 sql_from5 = sql_from4 sql_where5 = str_c(sql_where4, &quot; and organism_ch1 in (&#39;Homo sapiens&#39;, &#39;Mus musculus&#39;, &#39;Rattus norvegicus&#39;)&quot;, sep=&quot;\\n&quot;) res = dbGetQuery(mydb, str_c(sql_select5, sql_from5, sql_where5, sep=&quot;\\n&quot;)) kable(res) GSM GSE 133981 3727 We create a materialized view BIOQC_RES_FIL with bioqc results that are filted according to these criteria in db/views/bioqc_res_fil.sql, except that it also contains the GTEx signatures. `` 5.4.4 Select tissues Of which tissues are enough samples available that we can make a meaningful statement about contamination? sqlTissue = &quot; select /*+ parallel(16) */ tissue, count(distinct gsm) as samples from bioqc_res_fil group by tissue order by samples desc&quot; resTissue = dbGetQuery(mydb, sqlTissue) kable(resTissue) TISSUE SAMPLES blood 32548 liver 26732 lung 9553 kidney 7507 bone marrow 6536 brain 5719 heart 4813 breast tumor 3990 spleen 3506 adipose 2857 skeletal muscle 2445 skin 2271 hippocampus 2053 colon 1914 hepatocyte 1870 tumor 1627 white blood cells 1535 lymph node 1335 breast 1205 cerebellum 1175 testis 1128 pbmc 936 frontal cortex 805 placenta 766 pancreas 746 retina 711 pancreatic islets 645 thymus 638 ovary 549 prostate 522 hypothalamus 468 mammary gland 464 jejunum 446 prefrontal cortex 409 cortex 328 embryo 257 uterus 239 cervix 147 stomach 139 salivary gland 128 bladder 123 ventral midbrain 78 eye 69 adrenal gland 67 monocyte 59 neuroblastoma 27 plasma 9 "],
["tissue-migration.html", "6 Tissue Migration", " 6 Tissue Migration Now, detect samples we defined as contamined: * highly siginificant BioQC scores (min score per sample &gt;6) * signature outside ‘expected’ signature that is at least 6 higher than the highest score in expected signatures. * (outlier in study) We can find contamined studies with SQL only. To speed up things, we create a temporary table (rather a materialized view, but that’s not available on our old postgres server) filtering for samples, where a non-expected signature exceeds all expected signatures by a certain threshold (BioQC score &gt; 6, aka. ‘enrichment-ratio’). This table is created in db/queries/mk-extended_bioqc_res_table2.sql. We create a view contamined_samples that contains all contamined samples in db/queries/get_contamined_samples.sql. Second, we retrieve the information we need for the migration chart from that temporary table. query = &quot; select origin , destination , count(gsm) as \\&quot;count\\&quot; from bioqc_tissue_migration where enrichment_ratio &gt; 4 and rk = 1 and tissue_set = &#39;gtex_solid&#39; group by origin, destination order by origin, destination&quot; migration = dbGetQuery(mydb, query) set.seed(42) col = rand_color(length(unique(migration$ORIGIN))) chordDiagram(migration, grid.col=col, annotationTrack=&quot;grid&quot;, preAllocateTracks=1) circos.trackPlotRegion(track.index=1, panel.fun = function(x, y) { xlim = get.cell.meta.data(&quot;xlim&quot;) ylim = get.cell.meta.data(&quot;ylim&quot;) sector.name = get.cell.meta.data(&quot;sector.index&quot;) circos.text(mean(xlim), ylim[1] + .1, sector.name, facing = &quot;clockwise&quot;, niceFacing = TRUE, adj = c(0, 0.5)) circos.axis(h = &quot;top&quot;, labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 2) }, bg.border = NA) chordDiagram(migration[migration$ORIGIN != &#39;blood&#39; &amp; migration$DESTINATION!=&#39;blood&#39;,]) Contamination in total: We can also compose statistics about the origin of samples By time byYear = &quot; with contam_stats as ( select bcs.* , case when enrichment_ratio &gt; 4 then 1 else null end as is_contam from bioqc_contam_stats bcs ) select year , tgroup , count(gsm) as total , count(is_contam) as contamined , count(is_contam)/cast(count(gsm) as float) as ratio from contam_stats where tissue_set = &#39;gtex_solid&#39; group by year, tgroup order by ratio desc &quot; year = dbGetQuery(mydb, byYear) ggplot(data=year, aes(x=YEAR, y=RATIO)) + stat_summary(fun.y=&quot;mean&quot;, geom=&quot;bar&quot;) By country (that’s nice figures, but it’s not very representative… tissue-bias, statistical significance, …) byCountry = &quot; with contam_stats as ( select bcs.* , case when enrichment_ratio &gt; 4 then 1 else null end as is_contam from bioqc_contam_stats bcs ) select country , tgroup , count(gsm) as total , count(is_contam) as contamined , count(is_contam)/cast(count(gsm) as float) as ratio from contam_stats where tissue_set = &#39;gtex_solid&#39; group by country, tgroup order by ratio desc &quot; country = dbGetQuery(mydb, byCountry) country.2 = country[country$TGROUP == &#39;liver&#39;,] #country.2 = ddply(country[country$total &gt; 2000,], ~country,summarise,ratio=mean(ratio)) spdf &lt;- joinCountryData2Map(country.2, joinCode=&quot;NAME&quot;, nameJoinColumn=&quot;COUNTRY&quot;) mapCountryData(spdf, nameColumnToPlot=&quot;RATIO&quot;, catMethod=&quot;fixedWidth&quot;) By organism byOrganism = &quot; with contam_stats as ( select bcs.* , case when enrichment_ratio &gt; 4 then 1 else null end as is_contam from bioqc_contam_stats bcs ) select organism , tgroup , count(gsm) as total , count(is_contam) as contamined , count(is_contam)/cast(count(gsm) as float) as ratio from contam_stats where tissue_set = &#39;gtex_solid&#39; group by organism, tgroup order by ratio desc &quot; organism = dbGetQuery(mydb, byOrganism) tissues = c(&quot;blood&quot;, &quot;brain&quot;, &quot;kidney&quot;, &quot;liver&quot;) organism.2 = organism[organism$TGROUP %in% tissues, ] #ggplot(data=organism.2, aes(x=ORGANISM, y=RATIO)) + stat_summary(fun.y=&quot;mean&quot;, geom=&quot;bar&quot;) ggplot(data=organism.2, aes(x=ORGANISM, y=RATIO)) + geom_boxplot() + geom_point(aes(color=TGROUP)) "]
]
