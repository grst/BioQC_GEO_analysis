[
["index.html", "1 BioQC GEO Analysis 1.1 Introduction 1.2 The Experiment in Brief", " 1 BioQC GEO Analysis Systematically testing the GEO for tissue heterogeneity. Manuscript in preparation 1.1 Introduction Recently we created a software tool, BioQC, that detects tissue heterogeneity in gene expression data and shared it with the community of genome researchers via Bioconductor. The concept of tissue heterogeneity stems from our observations that gene expression data is often compromised by cells originating from other tissues than the target tissue of profiling. Tissue heterogeneity can be caused by physiological or pathological processes, such as immune cell infiltration. Alternatively, they can be caused by technical imperfection to separate complex or nearby tissues or even human errors. Failures in detecting tissue heterogeneity may have profound implications on data interpretation and reproducibility. As bioinformaticians working on drug discovery in the pharma industry, we are convinced that gene expression data available in publicly available databases such as NCBI Gene Expression Omnibus (GEO) or EBI ArrayExpress has great potential to catalyse new therapeutic agents. Disease signatures derived from disease models or patient biopsies, for instance, can be used to assess cellular models used for discovery and to guide compound selection. Molecular phenotypes of compounds, in another example, can be used to validate both efficacy and pre-clinical safety of compounds. Apparently all such applications depend critically on the quality of gene expression data. Several groups have scrutinised publicly available datasets and have identified deleterious factors of data quality such as batch effects, human error, and even data manipulation and faking. However, tissue heterogeneity has not been explicitly addressed so far and there is neither data nor knowledge about its prevalence. To fill this gap, we undertake a systematic investigation of publicly available gene expression datasets. 1.2 The Experiment in Brief BioQC implements a computationally efficient Wilcoxon-Mann-Whitney (WMW)-test which is applied to gene expression data on a sample-by-sample basis. Using BioQC, we can efficiently test for the enrichment of certain gene sets, or in this case tissue signatures. A tissue signature is a list of genes, which are predominantly expressed in a certain tissue. If the WMW-test shows a significant enrichment of a signature, we can conclude that the respective tissue is present in the sample. The authors of BioQC provide a list of more than 150 such signatures for a variety of tissues and cell types. For this study, we independently created and validated tissue signatures based on the GTEx dataset using pygenesig as described in Validating Signatures. We downloaded gene expression data from GEO using GEOquery and obtained the associated metadata from GEOmetadb. Using the metadata, we selected samples as described in sample selection. On all all these samples, we applied BioQC to obtain a p-value for each tissue signature and stored them alongside with the metadata in a database system (DBS). The process of setting up the database is described in Database Design. Finally, we identified contaminated samples from the signature scores. If a signature, which is not associated with the annotated tissue of origin, scores high, we assume the sample being heterogenous. In section Tissue Migration, we describe how we identify contaminated samples and discuss common pattern of tissue heterogenity. "],
["validating-signatures.html", "2 Validating Tissue Signatures 2.1 Data 2.2 Cross-Validation of signatures on the GTEx dataset 2.3 ‘solid’ signatures 2.4 Cross-Platform Cross-Species validation", " 2 Validating Tissue Signatures The authors of BioQC have taken three independent approaches to show that their signatures are valid and biologically meaningful. However, they did not break down the predictive performance (i.e. is the signature able to identify its tissue) of each signature with quantitative performance measures. To address this, we independently derived signatures on the GTEx dataset using gini-index. and performed both a 10-fold cross validation on the same dataset and a cross-species, cross-platform validation on the mouseGNF. To this end, we developed the python package pygenesig, a framework to create and validate signatures. In this chapter, we perform a 10-fold cross-validation on the GTEx dataset, calculating the precision and recall for each signature. perform a cross-species, cross-platform validation of the signatures generated on the GTEx dataset identify a set of tissues, that can be reliably and unabmigously identified with the BioQC method. 2.1 Data The Genotype Tissue Expression (GTEx) project is a comprehensive resource of tissue-specific gene expression data. We use this dataset to derive tissue-specific signatures. The data is human only and was generated using Illumina sequencing. We use the GNF Mouse GeneAtlas V3 as a control dataset to demonstrate that the gini-method is robust over multiple platforms and species. This dataset originates from mouse and was generated using the Affymetrix Mouse Genome 430 2.0 Array (GPL1261). 2.2 Cross-Validation of signatures on the GTEx dataset We use pygenesig-pipline to create and validate signatures on the GTEx v6 dataset. The data preparation steps are performed using these jupyter notebooks. The output of pygenesig-pipeline can be viewed here. Below, we summarize the prodecues described in these documents. We obtained the gene expression data and sample annotation from the GTEx portal. We collapsed gene expression data by HGNC symbol, aggregating by the sum. We performed a 10-fold cross-validation as follows: We split samples in 10 stratified folds, i.e. samples from all tissues are equally distributed across all folds. We use 9 folds to generate signatures using the gini method as described by the BioQC authors. These signatures were applied to the remaining fold using BioQC. We iterated over the folds such that each fold has been used for training and testing. The following heatmap shows the average BioQC score over all folds for each signature and each tissue. Figure 2.1: cross-validation of GTEx tissue signatures. Signatures are shown on the y-axis, the corresponding groups of samples on the x-axis. The tile shading indicates the average BioQC score of a signature on a group of samples. For better visibility of low scores, the colors are saturated at 30. As identifying contaminated/mislabled samples can be boiled down to a classification exercise, we are interested in the predictive performance of each signature. The following heatmap shows the confusion matrix of using the signatures for classification. A sample is considered as classified as a tissue, if the corresponding signature scores highest among all other signatures. Figure 2.2: Confusion matrix of the cross-validation 2.3 ‘solid’ signatures From the above matrices we learn that, while the vast majority of signatures yield a high score in the corresponding tissue, an unambigous classification of tissues is only viable for a subset of tissues. For instance, the different brain regions are hard to distinguish and so are physiologically close tissues (e.g. large and small intestine). Here, we reduce the dataset to a subset of tissues, which can be unambigously distinguished using the BioQC method (i.e. precision = recall = 1.0). We manually map the tissues from GTEx to a reduced subset of tissue names. The data is prepared to be ran using pygenesig-pipeline. The results are available in this jupyter notebook and summarized below. Again, the following heatmap shows the confusion matrix. All tissues have been correctly identified at Precision = Recall = 1.0. 2.4 Cross-Platform Cross-Species validation Arguably, in the above experiment, we could have built signatures based on human-specific genes, genes that can only be detected by a certain experimental platform or even experiment-specific batch effects instead of univerally translatable marker genes. To asses the translatability of the signatures, we tested the signatures generated above (human, Illumina sequencing) on the mouseGNF tissue expression atlas (mouse, Affymetrix microarray). Te procedure is described in this notebook. The following figure shows the score matrix of GTEx signatures against mouseGNF samples: The signatures Brain, Heart, Kidney, Liver, Skeletal Muscle, Pancreas, Skin and Testis identify the respective tissue despite the species and platform differences at a high (&gt;5) BioQC score. As expected Heart and Skeletal muscle also identify each other, however Heart scores still higher on heart samples and Skeletal muscle scores higher on skeletal muscles samples, therefore we retain both signatures. Surprisingly, Adrenal Gland, Ovary and Uterus are not able to identify the respective samples, despite having a high score in the cross-validation. We therefore exclude these signatures from the ‘gtex solid’ signature set. Unfortunately, Blood was not profiled in the mouseGNF dataset. We keep the signature nonetheless as it does not trigger any false positives. "],
["curating-data.html", "3 Curating Data 3.1 Selecting Samples by Metadata 3.2 Normalize Tissues 3.3 Map tissues to signatures", " 3 Curating Data 3.1 Selecting Samples by Metadata GEOmetadb is a SQLite database containing metadata associated with samples and studies from GEO. This database has proven to be tremendously helpful for selecting samples by tissue and organism. We integrate the database into the study’s DBS and describe how we select samples in detail in sample selection. 3.2 Normalize Tissues The annotation of tissues is inconsistent within GEO. A “liver” sample can be termed e.g. “liver”, “liver biopsy” or “primary liver”. We therefore need a way to normalize the tissue name. We did this manually for the most abundant tissues in this Excel sheet. 3.3 Map tissues to signatures In order to find out which samples show tissue heterogeniety, we first need to define which signatures we would ‘expect’ in a certain tissue. We therefore manually mapped signatures to the respective tissue type in this Excel sheet. For example, we map the signatures Intestine_Colon_cecum_NR_0.7_3 and Intestine_Colon_NR_0.7_3 to colon. We mapped all normalized tissues from above to the respective signatures, which have at least 500 samples. We mapped tissues with a lower sample count only if they formed a subset of an already mapped tissue (e.g. we mapped prefrontal cortex to brain although having less than 500 samples, because we already mapped signatures to brain.) Moreover, we ran into the issue, that some tissue signatures are not as specific as the annotation in the GEO. We therefore curated so-called tissue sets to combine them into groups. For example, it is hard to distinguish jejunum from colon, but easy to distinguish the two from other tissues. We therefore created a tissue set intestine, which contains both jejunum and colon and references all signatures associated with the two tissues. This information is part of the same Excel sheet. We created a tissue set bioqc_all which maps all tissues to all signatures provided by the authors of BioQC and a high-confidence tissue-set gtex_solid which only maps tissues to signatures that we could validate as high-confidence signatures in Validate Tissue Signatures. "],
["setup-database.html", "4 Setup Database 4.1 Tables explained 4.2 Import GEOmetadb 4.3 Import BioQC data 4.4 DBS as analysis engine and result storage", " 4 Setup Database We store meta information for GEO samples and BioQC p-values in an Oracle 11g database. We combine the metadata from GEOmetadb with tables to store signature scores generated with BioQC and manually curated annotations. The following figure shows the database scheme used for the study as entity-relationship (ER) diagram: Figure 2.2: Entitiy relationship diagram of the BioQC database scheme. Click the here for an enlarged version. Greenish tables are imported and adapted from GEOmetadb. Yellowish tables are additional tables designed for this study. Three dots (…) indicate columns from GEOmetadb which have been omitted in the visualisation because they are not relevant for this study. 4.1 Tables explained 4.1.1 GEOmetadb BIOQC_GSM: from GEOmetadb, meta information for all Samples in GEO BIOQC_GPL: from GEOmetadb, list of all Platforms (e.g. different types of microarrays) referenced in GEO. BIOQC_GSE: from GEOmetadb, list of Series (collections of samples) in GEO. BIOQC_GSE_GPL: from GEOmetadb, relation of Series and Platforms. Columns containing Series/Platform-specific gene expression statistics have been added which are used for a simple quality control. 4.1.2 BioQC BIOQC_TISSUES: List of all tissues manually annotated in Normalize Tissues. BIOQC_NORMALIZE_TISSUES: Stores the manually curated mapping of the original tissue name to a normalized tissue name. BIOQC_SIGNATURES: Stores gene signatures imported from a GMT file. BIOQC_TISSUE_SET: Stores the manually curated mapping of tissues to ‘expected signatures’. BIOQC_RES: Stores the p-value generated with BioQC for each signature in BIOQC_SIGNATURES and each samples in BIOQC_GSM. BIOQC_BIOQC_SUCCESS: List of all studies on which we successfully ran BioQC. This serves as ‘background’ for our analysis. 4.2 Import GEOmetadb First, we need to extract a list of tables: gdb = dbConnect(SQLite(), file.path(DATA_DIR, &quot;geometabase/GEOmetadb.sqlite&quot;)) tables = dbListTables(gdb) writeLines(tables, file(file.path(DATA_DIR, &quot;geometabase/tables.txt&quot;))) Then, we use a conversion script to export the SQL schema and the tables as csv, which can be easily imported into the Oracle DBS. We adjusted the GEOmetadb schema to match Oracle datatypes. Once the tables are imported, we check if all the tables have the same number of rows: # check for consistency for(table in tables) { count.query = sprintf(&quot;select count(*) from %s&quot;, table) count.query.ora = sprintf(&quot;select count(*) from bioqc_%s&quot;, table) print(count.query) expect_equal(dbGetQuery(gdb, count.query)[[1]], dbGetQuery(mydb, tolower(count.query.ora))[[1]]) } 4.2.1 Fix foreign key constraints Unfortunately, foreign key constraints are not enabled in the GEOmetadb SQLite database. It turned out that the GEOmetadb is not entirely consistent when trying to add such constraints in Oracle. We fixed missing parent keys by adding “stub” entries to the tables. The procedure is documented in this SQL script. 4.2.2 Extract Tissue annotation The tissue annotation for each sample is hidden in the characteristics_ch1 column of the BIOQC_GSM table. Since this information is essential for our study, we parsed it into a separate column using a regular expression. The procedure is documented in this SQL script. 4.2.3 Load annotation information To run BioQC, gene symbols need to be annotated in the gene expression matrix. To retrieve gene symbols, we are aware of two feasible approaches: the Bioconductor annotation packages (listed in GEOmetadb gpl.bioc_package) use the GEO annot_gpl files (“in general available for all GSE that are referenced by a GDS”1) To find out for which GSE in particular the latter option exists, we parsed the directory structure of the GEO ftp server: lftp -c &quot;open ftp://ftp.ncbi.nlm.nih.gov/geo/platforms/ &amp;&amp; find &amp;&amp; exit&quot; &gt; gpl_annot_ftp_tree.txt grep annot.gz gpl_annot_ftp_tree.txt | cut -d&quot;/&quot; -f5 | cut -d&quot;.&quot; -f1 &gt; gpl_annot.txt We add this information the the BIOQC_GPL table as a boolean flag indicating whether the respective platform has an annotation file. # tmp table sql = &quot;create table bioqc_gpl_annot(gpl varchar2(10) primary key, has_annot number(1))&quot; dbSendUpdate(mydb, sql) annot = read.table(&quot;db/data/gpl_annot.txt&quot;) annot = cbind(annot, rep(1, length(annot))) colnames(annot) = c(&quot;1&quot;, &quot;2&quot;) dbAppendDf(&quot;BIOQC_GPL_ANNOT&quot;, annot) # update gpl from tmp table sqlUpdateGpl = &quot; update bioqc_gpl g set has_annot = (select has_annot from bioqc_gpl_annot a where g.gpl = a.gpl)&quot; dbSendUpdate(mydb, sqlUpdateGpl) # drop tmp table sql = &quot;drop table bioqc_gpl_annot&quot; dbSendUpdate(mydb, sql) We compared the two approaches in Sample Selection. 4.2.4 Import summary statistics for each study To perform a simple quality control on each study we calculated the min, max, median, mean and quartiles of the expression values of each study in GEO. This process is documented in test_for_normalization.R and the project’s Makefile. We import the results into the database: study_stats = data.table(read_tsv(file.path(DATA_DIR, &quot;gse_tissue_annot/study_stats.txt&quot;))) study_stats = study_stats[,GSE:=sapply(as.character(study_stats[[1]]), geoIdFromPath)] study_stats = study_stats[,GPL:=lapply(as.character(study_stats[[1]]), gplFromPath)] setcolorder(study_stats, c(8, 9, 1:7)) study_stats[, &#39;filename&#39;] = NULL # remove file name dbSendUpdate(mydb, &quot;truncate table bioqc_tmp_gse_gpl&quot;) dbAppendDf(&quot;BIOQC_TMP_GSE_GPL&quot;, study_stats) dbSendUpdate(mydb, &quot;update bioqc_gse_gpl a set (study_mean, study_min, study_25, study_median, study_75, study_max) = (select study_mean, study_min, study_25, study_median, study_75, study_max from bioqc_tmp_gse_gpl b where a.gse = b.gse and (a.gpl = b.gpl or b.gpl is NULL))&quot;) 4.3 Import BioQC data We install the BioQC schema using this SQL script. 4.3.1 Signatures Import signatures into the database and create a single, consolidated gmt file. # Signatures shipped with BioQC (updated version from 2016-12-08) # download.file(&quot;http://bioinfo.bas.roche.com:8080/apps/gsea/genesets/exp.tissuemark.bioqc.roche.symbols.gmt&quot;, # &quot;data/expr.tissuemark.affy.roche.symbols.gmt&quot;) gmt2db(file.path(DATA_DIR, &quot;expr.tissuemark.affy.roche.symbols.gmt&quot;)) # control signatures generated from GTEx using *pygenesig* gmt2db(&quot;../pygenesig-example/results/gtex_v6_gini_0.8_3/signatures.gmt&quot;, source=&#39;gtex_v6_gini.gmt&#39;) gmt2db(&quot;../pygenesig-example/results/gtex_v6_solid_gini_0.8_1/signatures.gmt&quot;, source=&#39;gtex_v6_gini_solid.gmt&#39;) # baseline signatures (random/housekeeping) gmt2db(&quot;../pygenesig-example/results/baseline_signatures.gmt&quot;) # pathway gene sets not relevant for this study # gmt2db(&quot;../BioQC_correlated-pathways/go.bp.roche.symbols.gmt.uniq&quot;) # gmt2db(&quot;../BioQC_correlated-pathways/MetaBase.downstream.expression.gmt&quot;) # gmt2db(&quot;../BioQC_correlated-pathways/path.ronet.roche.symbols.gmt.ascii&quot;) # save imported signatures to consolidated gmt file db2gmt(&quot;results/gmt_all.gmt&quot;) 4.3.2 Tissue Annotation Import the manually curated tissues from Excel into the database. normalized_tissues = data.table(read_excel(&quot;manual_annotation/tissue_annotation.xlsx&quot;, sheet = 1)) tissues = unique(normalized_tissues[!is.na(TISSUE_NORMALIZED),&quot;TISSUE_NORMALIZED&quot;, with=FALSE]) tab_normalized = normalized_tissues[!is.na(TISSUE_NORMALIZED),c(&quot;TISSUE&quot;, &quot;TISSUE_NORMALIZED&quot;), with=FALSE] dbAppendDf(&quot;BIOQC_TISSUES&quot;, tissues) dbAppendDf(&quot;BIOQC_NORMALIZE_TISSUES&quot;, tab_normalized) 4.3.3 Tissue Sets Import the manually curated tissue sets from Excel into the database. bioqc_all = read_excel(&quot;manual_annotation/tissue_annotation.xlsx&quot;, sheet = 3) gtex_all = read_excel(&quot;manual_annotation/tissue_annotation.xlsx&quot;, sheet = 4) gtex_solid = read_excel(&quot;manual_annotation/tissue_annotation.xlsx&quot;, sheet = 5) bioqc_solid = read_excel(&quot;manual_annotation/tissue_annotation.xlsx&quot;, sheet = 6) signatureset2db(bioqc_all, &quot;bioqc_all&quot;) signatureset2db(gtex_solid, &quot;gtex_solid&quot;) signatureset2db(gtex_all, &quot;gtex_all&quot;) signatureset2db(bioqc_solid, &quot;bioqc_solid&quot;) 4.3.4 BioQC results Once we ran the analysis, we manually import the list of samples on which we successfully applied BioQC and the respective p-values into the tables BIOQC_BIOQC_SUCCESS and BIOQC_RES: bioqc_melt_all.uniq.tsv bioqc_success.txt 4.4 DBS as analysis engine and result storage We do not only use the database as pure data storage, but also as data analysis engine, harvesting the power of SQL. (See sections sample selection and contamination analysis). We save intermediate results of time-consuming queries in so-called materialized views, which are pysical snapshots of a query’s result. https://bioconductor.org/packages/release/bioc/manuals/GEOquery/man/GEOquery.pdf↩ "],
["sample-selection.html", "5 Sample Selection and Processing 5.1 Sample Preselection 5.2 Sample Processing with BioQC 5.3 Sample Post-selection", " 5 Sample Selection and Processing 5.1 Sample Preselection Here, we document the sample selection process before running BioQC. 5.1.1 Required annotation A sample is usable for this study, if the gene symbos are annotated (requirement to run BioQC) the tissue of origin is annotated (requirment to draw conclusions about contamination) We consider two approaches for annotating gene symbols: Using the Bioconductor AnnotationDbi package. The GEOmetadb provides a mapping of the GPL identifier to these packages. Using the annotGPL=TRUE option of GEOquery’s getGEO. This requires an annotation file being available for the respective platform. We retrieved a list of the available annotation files in an earlier step. We compare the two methods with respect to the amount of usable samples that we can get. We create the ‘annotation statistics’ using an sql script and calculate these Venn diagrams: The getGEO method appears to be the more powerful method. Ideal would be a combination of the two, however, for the sake of simplicity, we stick to getGEO, loosing 499 studies (35602 samples). This leaves us with the following filtering result: comment GSM GSE total 1945417 73719 tissue annotated 760798 24267 annotation file available 768346 31579 tissue and annotation file 275206 9632 5.1.2 Export list of samples We store the respective GSE identifiers in results/gse_lists/gse_tissue_annotation.txt: sqlGse = &quot; select distinct gse from ( select * from bioqc_studies_has_tissue intersect select * from bioqc_studies_has_annot) u&quot; gse = dbGetQuery(mydb, sqlGse) writeLines(gse$GSE, file(gse.file)) 5.2 Sample Processing with BioQC The following processes are ressource intensive, therefore we execute them on a high performance cluster (HPC). We use chunksub to distribute the list of sample ids to the workers. This involves four major steps which are also documented in the project’s Makefile. We download the studies with GEOquery and store them as R ExpressionSet using the R script geo_to_eset.R. For some series, the download is not successful. We annotated human orthologous genes for all studies using ribiosAnnotation in annotate_eset.R. This is necessary as the tissue signatures are built on a human dataset. The annotation failes for species which are not in the ribios database. We run BioQC on these studies use run_bioqc.R. Finally, import the BioQC results into the database. 5.3 Sample Post-selection The failures during download and annotation reduce the number of samples available to our study. sql_select = &quot; select /*+ USE_HASH(bs, bgg) parallel(16) */ count(distinct bg.gsm) as GSM , count(distinct bgg.gse) as GSE&quot; sql_from = &quot; from bioqc_bioqc_success bs join bioqc_gsm bg on bg.gsm = bs.gsm join bioqc_gse_gsm bgg on bgg.gsm = bs.gsm &quot; sql_where = &quot;&quot; res = dbGetQuery(mydb, str_c(sql_select, sql_from, sql_where, sep=&quot;\\n&quot;)) kable(res) GSM GSE 253210 8083 5.3.1 Excluding multi-channel microarrays Multi channel microarrays date back to the early age of gene expression studies. They don’t provide absolute gene expression data and are not meaningful outside their experimental context. We therefore exclude these experiments: sql_select2 = sql_select sql_from2 = sql_from sql_where2 = str_c(sql_where, &quot;where channel_count = 1&quot;, sep=&quot;\\n&quot;) res = dbGetQuery(mydb, str_c(sql_select2, sql_from2, sql_where2, sep=&quot;\\n&quot;)) kable(res) GSM GSE 235237 7561 5.3.2 Exclude non-mapped tissues We exclude samples that have a tissue annotated, but it is not mapped to a normalized tissue. sql_select3 = sql_select2 sql_from3 = str_c(sql_from2, &quot; join bioqc_normalize_tissues bnt on bnt.tissue_orig = lower(bg.tissue_orig)&quot;, sep=&quot;\\n&quot;) sql_where3 = sql_where2 res = dbGetQuery(mydb, str_c(sql_select3, sql_from3, sql_where3, sep=&quot;\\n&quot;)) kable(res) GSM GSE 136230 3800 5.3.3 Select organisms We were interested in the organism distribution. sql_select4 = str_c(sql_select3, &quot;, bg.organism_ch1&quot;, sep=&quot;\\n&quot;) sql_from4 = sql_from3 sql_where4 = sql_where3 res = dbGetQuery(mydb, str_c(sql_select4, sql_from4, sql_where4, &quot; group by organism_ch1 order by gsm desc&quot;, sep=&quot;\\n&quot;)) kable(res) GSM GSE ORGANISM_CH1 66316 1228 Homo sapiens 38109 2270 Mus musculus 29909 278 Rattus norvegicus 1082 24 Macaca mulatta 259 7 Macaca fascicularis 202 2 Mus musculus musculus x M. m. domesticus 80 2 Cercocebus atys 57 1 Oryctolagus cuniculus 36 1 Chlorocebus aethiops 32 3 Mus musculus domesticus 25 1 Pan troglodytes 23 1 Papio cynocephalus 19 1 Mus spretus 18 1 Capra hircus 16 1 Phodopus sungorus 12 1 Mus musculus musculus x M. m. castaneus 12 1 Papio hamadryas 8 1 Macaca nemestrina 6 1 Mus musculus castaneus 6 1 Mus musculus musculus 3 1 Mus sp. Results suggest that it makes sense to limit the analysis to the three main organisms: H. sapiens, M. musculus, R. norvegicus. This makes also sense as these species are closesly related and therefore the signatures are more likely to translate within these species. We are left with the following amount of samples: sql_select5 = sql_select3 sql_from5 = sql_from4 sql_where5 = str_c(sql_where4, &quot; and organism_ch1 in (&#39;Homo sapiens&#39;, &#39;Mus musculus&#39;, &#39;Rattus norvegicus&#39;)&quot;, sep=&quot;\\n&quot;) res = dbGetQuery(mydb, str_c(sql_select5, sql_from5, sql_where5, sep=&quot;\\n&quot;)) kable(res) GSM GSE 134334 3757 5.3.4 Quality control In this step we seek to identify studies on which BioQC cannot work due to poor data quality or data processing steps that remove the relative expression of a gene within a sample, e.g. per-gene normalization. We will first filter samples by applying a cutoff-value to statistics on the gene expression data. Second, we will use an ubiquitous signature containing housekeeping genes as an indicator if BioQC returns a sensible result on the given sample. On each study, we have calculated the mean of each gene over all samples. Of this series of means, we calculate the IQR. If a per-gene normalization has been applied, this value should be close to zero. This histogram shows a distribution of all IQRs over all remaining studies: sql_select_hist = &quot; select /*+ USE_HASH(bs, bgg) parallel(16) */ distinct bgg.gse , study_median , abs(study_75-study_25) as IQR &quot; sql_from_hist = str_c(sql_from5, &quot; join bioqc_gse_gpl bgl on bgg.gse = bgl.gse and bg.gpl = bgl.gpl&quot;, sep=&quot;\\n&quot;) sql_where_hist = sql_where5 res = dbGetQuery(mydb, str_c(sql_select_hist, sql_from_hist, sql_where_hist, sep=&quot;\\n&quot;)) sm = res$IQR hist(sm[sm &gt; 0 &amp; sm &lt; 25], breaks=seq(0, 25, .25), main=&quot;Variance between gene for each study (IQR)&quot;, xlab=&quot;median gene expression (only values up to 25)&quot;) abline(v=.5, col=&quot;blue&quot;) minor.tick(nx=5) We exclude all studies having a very low variance between genes (IQR &lt; 0.5). Remaining samples: sql_select6 = sql_select3 sql_from6 = str_c(sql_from5, &quot; join bioqc_gse_gpl bgl on bgg.gse = bgl.gse&quot;, sep=&quot;\\n&quot;) sql_where6 = str_c(sql_where5, &quot; and abs(study_75 - study_25) &gt;= .5&quot;, sep=&quot;\\n&quot;) res = dbGetQuery(mydb, str_c(sql_select6, sql_from6, sql_where6, sep=&quot;\\n&quot;)) kable(res) GSM GSE 96074 3129 Now, we have a look at the p-value distribution of the signature termed awesome_housekeepers containing ubiquitous genes. The gene expression of these genes can be assumed to be more or less constant over all tissue types, therefore this signature should score high in every sample. Awesome Housekeepers The orange curve is the pvalue distribution of the housekeeping signature. The blue curve shows the distribution of a random control signature containing 100 randomly chosen genes. sql_select_hk = &quot; select /*+ USE_HASH(bs, bgg) parallel(16) */ br.signature , br.pvalue , bs.name &quot; sql_from_hk = str_c(sql_from6, &quot; join bioqc_res br on br.gsm = bg.gsm join bioqc_signatures bs on bs.id = br.signature&quot;, sep=&quot;\\n&quot;) sql_where_hk = str_c(sql_where6, &quot; and br.signature in (56184, 56206) -- awesome_housekeepers, random_100_0&quot;) res = data.table(dbGetQuery(mydb, str_c(sql_select_hk, sql_from_hk, sql_where_hk, sep=&quot;\\n&quot;))) invisible(res[,SCORE:=absLog10p(as.numeric(PVALUE))]) ggplot(res, aes(x=SCORE)) + geom_density(aes(color=NAME)) + geom_vline(xintercept = 5, color=&quot;blue&quot;) + theme(legend.position = &quot;top&quot;) We exclude all samples for which awesome_housekeepers scores with &lt;= 5, i.e. pvalue &gt;= 1e-5. sql_select7 = sql_select6 sql_from7 = str_c(sql_from6, &quot; join bioqc_res br on br.gsm = bg.gsm&quot;, sep=&quot;\\n&quot;) sql_where7 = str_c(sql_where6, &quot; and signature = 56184 and pvalue &lt; 1e-5&quot;, sep=&quot;\\n&quot;) res = dbGetQuery(mydb, str_c(sql_select7, sql_from7, sql_where7, sep=&quot;\\n&quot;)) kable(res) GSM GSE 81845 2926 This is the ‘background’ of samples on which we test for tissue contamination. We store the selected samples alongside with meta information required for the analysis in the materialized view BIOQC_SELECTED_SAMPLES in our DBS. Here is the SQL script generating the materialized view. 5.3.5 Tissue abundance The following table shows how many samples are available for each tissue: sqlTissue = &quot; select /*+ parallel(16) */ tissue, count(distinct gsm) as samples from bioqc_selected_samples group by tissue order by samples desc&quot; resTissue = dbGetQuery(mydb, sqlTissue) kable(resTissue) TISSUE SAMPLES blood 18064 liver 12925 lung 7586 bone marrow 3911 kidney 3540 breast tumor 3465 brain 3452 heart 2402 spleen 2302 adipose 2214 skin 1927 skeletal muscle 1830 hippocampus 1573 colon 1463 lymph node 1120 hepatocyte 1094 cerebellum 1094 tumor 1036 breast 795 frontal cortex 729 placenta 678 pbmc 665 white blood cells 664 testis 627 retina 596 pancreas 586 thymus 551 pancreatic islets 488 ovary 455 mammary gland 395 jejunum 380 prostate 330 hypothalamus 271 cortex 256 prefrontal cortex 249 synovial tissue 234 uterus 232 embryo 217 monocyte 162 stomach 127 bladder 123 cervix 95 ventral midbrain 74 eye 69 salivary gland 48 neuroblastoma 45 adrenal gland 39 fibroblast 21 synovial fibroblast 8 "],
["contamination-analysis.html", "6 Analyse Contamination 6.1 Input Tables 6.2 Processing Steps explained", " 6 Analyse Contamination The heartpiece of the study is this sql script which identifies heterogenous samples. In this section we will go through the different analysis steps performed in the script. 6.1 Input Tables BIOQC_SELECTED_SAMPLES: the samples resulting from the selection process including metadata BIOQC_TISSUE_SET: the manual mapping of tissues to signatures (“expected signatures”) BIOQC_RES: the p-values for each sample and signature. 6.2 Processing Steps explained 6.2.1 BIOQC_SELECTED_SAMPLES_TSET We join BIOQC_SELECTED_SAMPLES on BIOQC_TISSUE_SET and BIOQC_RES to attach the expected tissue group to each sample and find the highest scoring signature within each tissue group. Example: A sample (GSM1234) is annotated as ‘colon tissue’. ‘colon’ is part of the tissue group ‘intestine’. We search for the highest scoring signature within ‘intestine’ and keep it. The following results for GSM1234 GSM TISSUE TISSUE_SET EXPECTED_SIGNATURE PVALUE GSM1234 colon intestine Colon 1e-10 GSM1234 colon intestine Jejunum 1e-5 would be aggretated into: GSM TISSUE TGROUP MIN_EXP_SIG MIN_EXP_SIG_PVALUE GSM1234 colon intestine Colon 1e-10 6.2.2 BIOQC_RES_TSET We join the BioQC results (p-value for each signature and sample) from BIOQC_RES with BIOQC_TISSUE_SET to map the signatures back to their tissue group. Example: The following results for GSM1234 GSM SIGNATURE PVALUE GSM1234 Colon 1e-10 GSM1234 Jejunum 1e-5 GSM1234 Liver 1e-5 would be aggretated into: GSM MIN_FOUND_SIG MIN_FOUND_PVALUE FOUND_TGROUP GSM1234 Colon 1e-10 intestine GSM1234 Liver 1e-5 liver 6.2.3 BIOQC_CONTAMINATION We now join the two above tables, BIOQC_RES_TSET and BIOQC_SELECTED_SAMPLES_TSET, in order to set the ‘expected’ and ‘found’ tissue groups into relation. The resulting table can be filtered by a score cutoff in order to only retrieve the siginificant entries. Example: The join of the above examples would look like GSM TISSUE TGROUP MIN_EXP_SIG MIN_EXP_PVALUE FOUND_TGROUP MIN_FOUND_SIG MIN_FOUND_PVALUE GSM1234 colon intestine Colon 1e-10 intestine Colon 1e-10 GSM1234 colon intestine Colon 1e-10 liver Liver 1e-5 "],
["results-preliminary.html", "7 Results [PRELIMINARY] 7.1 Detection of tissues 7.2 Detection of outliers 7.3 signature-free method?", " 7 Results [PRELIMINARY] sql = &quot; select /*+ parallel(16) */ * from bioqc_contamination where tissue_set = &#39;gtex_solid&#39; &quot; res = data.table(dbGetQuery(mydb, sql)) res = res[,MIN_FOUND_PVALUE:=as.numeric(MIN_FOUND_PVALUE)] res = res[,MIN_EXP_PVALUE:=as.numeric(MIN_EXP_PVALUE)] res = res[,EXP_SCORE:=absLog10p(MIN_EXP_PVALUE)] res = res[,FOUND_SCORE:=absLog10p(MIN_FOUND_PVALUE)] res = res[,total_tissue:=length(unique(GSM)), by=c(&quot;TGROUP&quot;)] #res[,cnt_per_group:=length(unique(GSM)), by=c(&quot;GPL&quot;, &quot;TGROUP&quot;)] #res = res[cnt_per_group &gt;= 100] pbonf = 0.05 / nrow(res) 7.1 Detection of tissues In general, a signature finds its corresponding tissue: ggplot(res, aes(x=FOUND_TGROUP, y=FOUND_SCORE)) + geom_boxplot() + facet_wrap(~TGROUP) + theme(axis.text.x=element_text(angle = 45, hjust = 1)) Although, for each tissue there are samples in which the signature is not enriched (pvalue &gt;= 0.05) at a single sample level: matching = res[TGROUP == FOUND_TGROUP] not_enriched = data.table(sqldf(&quot;select tgroup , sum(case when MIN_FOUND_PVALUE &gt;= 0.05 then 1 else 0 end) as not_enriched , count(distinct gsm) as total from matching group by tgroup&quot;)) ## Loading required package: tcltk ## Warning: Quoted identifiers should have class SQL, use DBI::SQL() if the ## caller performs the quoting. not_enriched[, ratio:=not_enriched/total] ## TGROUP not_enriched total ratio ## 1: blood 1331 19393 0.06863301 ## 2: brain 504 7624 0.06610703 ## 3: heart 36 2402 0.01498751 ## 4: kidney 345 3540 0.09745763 ## 5: liver 315 14019 0.02246951 ## 6: pancreas 297 586 0.50682594 ## 7: skeletal muscle 98 1830 0.05355191 ## 8: skin 321 1927 0.16658018 ## 9: testis 418 627 0.66666667 ggplot(not_enriched, aes(x=TGROUP, y=ratio)) + geom_bar(stat=&quot;identity&quot;) And, there are outliers (=tissue heterogeniety). 7.2 Detection of outliers 7.2.1 Sample-against-sample method it is not a valid approach to compare samples against other samples. Even if stratified by platform, different experimental conditions and data processing steps could influence the BioQC score in a way that it would fall outside a confidence interval. taking (1) into account we could detect outliers at a study level. This can be trivially done by computing a z-score on the BioQC scores. The statistically correct approach to check if a signature is more enriched in one sample than another would be as follows: For two samples \\(S_1\\) and \\(S_2\\) and a signature \\(K\\): \\[ H_0: \\text{genes in K are not more enriched in } S_1 \\text{ than in } S_2 \\\\ H_1: \\text{genes in K are more enriched in } S_1 \\text{ than in } S_2 \\] which translates in the context of the WMW test into \\[ H_1: \\text{The median rank of signature genes in } S_1 \\text{ is higher than the median rank of signature genes } S_2 \\] Let \\(U_1\\) and \\(U_2\\) be the WMW test statistics for \\(S_1\\) and \\(S_2\\) respectively, with \\[ U_1 \\sim \\mathcal{N}(\\mu_1, \\sigma_1^2) \\\\ U_2 \\sim \\mathcal{N}(\\mu_2, \\sigma_2^2) \\] We define the random variable \\[ \\Delta = U_1 - U_2 \\] Which is distributed, assuming independence of the two samples, according to \\[ \\Delta \\sim \\mathcal{N}(\\mu_1 - \\mu_2, \\sigma_1^2 - \\sigma_2^2). \\] So that we now can easily test our hypothesis: \\[ H_1: \\Delta &gt; 0. \\] 7.2.2 Within-Sample Method Another approach is to check, which signature scores highest in a sample. Like that we classify a sample based on the signature, independent of the original annotation. As shown in the signature validation this works reliably with a sensitivity and specificity of 1.0 for the selected subset of signatures. Acknowledging that we have tested the signatures only on a small set of samples, we can add an additional safety margin, by requiring that the p-value exceeds the p-value of the ‘expected signature’ at least by 2 orders of magnitude. The downside of this approach is, that it will only detect heavily contaminated or mislabeled samples. Also, some signatures have a higher score than others in general, which further limits our detection limit. For instance, it will be relatively easy to detect liver contamination in pancreas, while it is hard to detect pancreas contamination in liver. We filter the results according to this criterion: res = res[,score_ratio:=FOUND_SCORE - EXP_SCORE] fil = res[TGROUP != FOUND_TGROUP &amp; score_ratio &gt; 2] #### exclude &#39;double contaminations&#39; fil = fil[, rk:=frankv(FOUND_SCORE, order=-1), by=c(&quot;GSM&quot;, &quot;GPL&quot;, &quot;TGROUP&quot;)] fil = fil[rk==1] And display the ‘contamination matrix’ aggr = sqldf(&#39;select TGROUP, FOUND_TGROUP, count(GSM) as cnt from fil group by TGROUP, FOUND_TGROUP&#39;) ggplot(aggr, aes(y=TGROUP, x=FOUND_TGROUP)) + geom_tile(aes(fill=cnt)) + geom_text(aes(label=cnt)) The same can be visualized as ‘migration chart’ set.seed(42) col = rand_color(length(unique(aggr$TGROUP))) names(col) = unique(aggr$TGROUP) chordDiagram(aggr, grid.col=col, annotationTrack=&quot;grid&quot;, preAllocateTracks=1) circos.trackPlotRegion(track.index=1, panel.fun = function(x, y) { xlim = get.cell.meta.data(&quot;xlim&quot;) ylim = get.cell.meta.data(&quot;ylim&quot;) sector.name = get.cell.meta.data(&quot;sector.index&quot;) circos.text(mean(xlim), ylim[1] + .1, sector.name, facing = &quot;clockwise&quot;, niceFacing = TRUE, adj = c(0, 0.5), cex=2) circos.axis(h = &quot;top&quot;, labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 2) }, bg.border = NA) The fraction of contaminated samples per tissue: per_tissue = sqldf(&quot;select tgroup , total_tissue as TOTAL , count(gsm) as CONTAMINATED , count(gsm)/cast(total_tissue as float) as RATIO from fil group by tgroup&quot;) # png(filename = &quot;contamination.png&quot;, width = 1200, height=600) ggplot(data=per_tissue, aes(x=TGROUP, y=RATIO)) + geom_bar(stat=&quot;identity&quot;) + xlab(&quot;tissue&quot;) + ylab(&quot;fraction contaminated&quot;) These are actually so few examples, that we can have a look at them manually: sql = &quot; select * from bioqc_gse_gsm &quot; all_gse = data.table(dbGetQuery(mydb, sql)) setkey(all_gse, GSM) contam_studies = merge(fil, all_gse, all=FALSE, by=c(&quot;GSM&quot;)) datatable(sqldf(&quot;select GSE, GSM, GPL, TGROUP, FOUND_TGROUP, ORGANISM, EXP_SCORE, FOUND_SCORE, score_ratio from contam_studies order by gse asc, score_ratio desc&quot;)) 7.2.3 Using the bioqc_solid signature set We can re-run the above analysis with the signatures provided by the BioQC authors. These signatures are not as toroughly validated as the ‘gtex solid’ set used above. Nonetheless it is interesting (1) to compare the results and (2) to take additional tissues into account. sql = &quot; select /*+ parallel(16) */ * from bioqc_contamination where tissue_set = &#39;bioqc_solid&#39; &quot; res_bqc = data.table(dbGetQuery(mydb, sql)) res_bqc = res_bqc[,MIN_FOUND_PVALUE:=as.numeric(MIN_FOUND_PVALUE)] res_bqc = res_bqc[,MIN_EXP_PVALUE:=as.numeric(MIN_EXP_PVALUE)] res_bqc = res_bqc[,EXP_SCORE:=absLog10p(MIN_EXP_PVALUE)] res_bqc = res_bqc[,FOUND_SCORE:=absLog10p(MIN_FOUND_PVALUE)] res_bqc = res_bqc[,total_tissue:=length(unique(GSM)), by=c(&quot;TGROUP&quot;)] #res[,cnt_per_group:=length(unique(GSM)), by=c(&quot;GPL&quot;, &quot;TGROUP&quot;)] #res = res[cnt_per_group &gt;= 100] pbonf_bqc = 0.05 / nrow(res_bqc) Again, we note that the signatures in general are highly specific. ggplot(res_bqc, aes(x=FOUND_TGROUP, y=FOUND_SCORE)) + geom_boxplot() + facet_wrap(~TGROUP) + theme(axis.text.x=element_text(angle = 45, hjust = 1)) We filter the results according to the cutoff res_bqc = res_bqc[,score_ratio:=FOUND_SCORE - EXP_SCORE] fil_bqc = res_bqc[TGROUP != FOUND_TGROUP &amp; score_ratio &gt; 2] #### exclude &#39;double contaminations&#39; fil_bqc = fil_bqc[, rk:=frankv(FOUND_SCORE, order=-1), by=c(&quot;GSM&quot;, &quot;GPL&quot;, &quot;TGROUP&quot;)] fil_bqc = fil_bqc[rk==1] and display the ‘contamination matrix’ aggr = sqldf(&#39;select TGROUP, FOUND_TGROUP, count(GSM) as cnt from fil_bqc group by TGROUP, FOUND_TGROUP&#39;) ggplot(aggr, aes(y=TGROUP, x=FOUND_TGROUP)) + geom_tile(aes(fill=cnt)) + geom_text(aes(label=cnt)) Investigtation why this approach shows many more hits for blood and muscle contamination has shown that the positive hits are mainly due to single-cell blood signatures (e.g. Monocytes) and the ‘smooth muscle’ muscle signature which has not been profiled in the gtex dataset (data not shown). 7.3 signature-free method? To find more subtle contamination, we could conduct an exemplary study searching for pancreas contamination in kidney. This is a likely contamination in mouse due to the spatial spatial closeness of the organs, as already noted by the BioQC authors. We could do so by assessing the abundance of the Elastase and Amylase genes which are only expressed in pancreas. "]
]
