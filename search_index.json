[
["index.html", "1 BioQC GEO Analysis 1.1 Introduction 1.2 The Experiment in Brief", " 1 BioQC GEO Analysis Systematically testing the GEO for tissue heterogeneity. Manuscript in preparation 1.1 Introduction Recently we created a software tool, BioQC, that detects tissue heterogeneity in gene expression data and shared it with the community of genome researchers via Bioconductor. The concept of tissue heterogeneity stems from our observations that gene expression data is often compromised by cells originating from other tissues than the target tissue of profiling. Tissue heterogeneity can be caused by physiological or pathological processes, such as immune cell infiltration. Alternatively, they can be caused by technical imperfection to separate complex or nearby tissues or even human errors. Failures in detecting tissue heterogeneity may have profound implications on data interpretation and reproducibility. As bioinformaticians working on drug discovery in the pharma industry, we are convinced that gene expression data available in publicly available databases such as NCBI Gene Expression Omnibus (GEO) or EBI ArrayExpress has great potential to catalyse new therapeutic agents. Disease signatures derived from disease models or patient biopsies, for instance, can be used to assess cellular models used for discovery and to guide compound selection. Molecular phenotypes of compounds, in another example, can be used to validate both efficacy and pre-clinical safety of compounds. Apparently all such applications depend critically on the quality of gene expression data. Several groups have scrutinised publicly available datasets and have identified deleterious factors of data quality such as batch effects, human error, and even data manipulation and faking. However, tissue heterogeneity has not been explicitly addressed so far and there is neither data nor knowledge about its prevalence. To fill this gap, we undertake a systematic investigation of publicly available gene expression datasets. 1.2 The Experiment in Brief BioQC implements a computationally efficient Wilcoxon-Mann-Whitney (WMW) test which is applied to gene expression data on a sample-by-sample basis. Using BioQC, we can efficiently test for the enrichment of certain gene sets, or in this case tissue signatures. These tissue signatures are lists of genes, which are predominantly expressed in a certain tissue. If a signature yields a small p-value in the WMW-test we can therefore conclude that the respective tissue is present in the sample. The authors of BioQC provide a list of more than 150 such signatures for a variety of tissues and cell types. For this study, we independently created and validated tissue signatures based on the GTEx dataset using pygenesig as described in Validating Signatures. We downloaded gene expression data from GEO using GEOquery and obtained the associated metadata from GEOmetadb. Using the metadata, we selected samples as described in sample selection. On all all these samples, we applied BioQC to obtain a p-value for each tissue signature and stored them alongside with the metadata in a database system (DBS). The process of setting up the database is described in Database Design. Finally, we identified contamined samples from the signature scores. If a signature scores high, which is not associated with the annotated tissue, we assume the sample being heterogenous. In section Tissue Migration, we describe how we identify contamined samples and discuss common pattern of tissue heterogenity. "],
["validating-signatures.html", "2 Validating Tissue Signatures 2.1 Data 2.2 Cross-Validation of signatures on the GTEx dataset 2.3 Cross-species Cross-platform validation on mouse", " 2 Validating Tissue Signatures The authors of BioQC have taken three independent approaches to show that their signatures are valid and biologically meaningful. However, they did not break down the predictive performance (i.e. is the signature able to identify its tissue) of each signature with quantitative performance measures. To address this, we independently derived signatures on the GTEx dataset using gini-index. and performed both a 10-fold cross validation on the same dataset and a cross-species, cross-platform validation on a different dataset. To this end, we created the python package pygenesig, a framework to create and validate signatures. In this chapter, we perform a 10-fold cross-validation on the GTEx dataset, calculating the sensitivity, specificity and precition for each signature. perform a cross-species, cross-platform validation of the signatures generated on the GTEx dataset identify a set of tissues, that can be reliably and unabmigously identified with the BioQC method. 2.1 Data The Genotype Tissue Expression (GTEx) project is a comprehensive resource of tissue-specific gene expression data. We use this dataset to derive tissue-specific signatures. The data is human only and was generated using Illumina sequencing. We use the GNF Mouse GeneAtlas V3 as a control dataset to demonstrate that the gini-method is robust over multiple platforms and species. This dataset originates from mouse and was generated using the Affymetrix Mouse Genome 430 2.0 Array (GPL1261). 2.2 Cross-Validation of signatures on the GTEx dataset import sys %load_ext autoreload %autoreload 1 %aimport pygenesig.validation %aimport pygenesig.gini %aimport pygenesig.bioqc %aimport pygenesig.tools %aimport pygenesig.perfmeasures %matplotlib inline from pygenesig.validation import * from pygenesig.gini import * from pygenesig.bioqc import * from pygenesig.tools import * import pygenesig.perfmeasures as pm import numpy as np import pandas as pd import sklearn.metrics as skm import os.path import dask from distributed import Client, progress import dask.async import dask.diagnostics import seaborn as sns sns.set_style(&quot;ticks&quot;, {&quot;axes.grid&quot; : True}) from pylab import * We use dask for parallel execution of the cross-validation: c = Client(&quot;10.114.185.14:8786&quot;) We load the preprocessed GTEx dataset. The preprocessing steps are described in this notebook. expr_file = &quot;../data/gtex/exprs.npy&quot; target_file = &quot;../data/gtex/target.csv&quot; splitter = sklearn.model_selection.StratifiedKFold(n_splits=10) signature_generator = GiniSignatureGenerator signature_tester = BioQCSignatureTester Use the automated cross-validation procedure from pygenesig: sig_list, res_list = cross_validate_signatures(expr_file, target_file, signature_generator, signature_tester, splitter) sig_f, res_f = c.compute([sig_list, res_list], sync=False) progress([sig_f, res_f]) Obtain the signatures and confusion matrices from the dask workers: signatures = sig_f.result() cms = res_f.result() 2.2.1 Signature overlap between the folds The box-plot shows the overlap of the signatures between the different folds. A high jaccard index indicates stability of the signatures between the folds. pairwise_jaccard = pairwise_jaccard_ind(signatures) fig, ax = subplots(figsize=(10,5)) data=pd.DataFrame(pairwise_jaccard) sns.boxplot(data=data, ax=ax) ax.set_title(&quot;Pairwise Jaccard Index&quot;) ax.set_xticklabels(data.columns, rotation=90); png 2.2.2 Confusion Matrix The confusion matrix shows which tissues tend to be confused with others. For example, we can see that it is difficult to differntiate between colon and small intestine. The confusion matrix below shows the average counts over the 10 folds per tissue. That means the matrix is not corrected for the number of samples per tissue. conf_mat_mean = np.mean(np.array(cms), axis=0) sig_labels = BioQCSignatureTester.sort_signatures(signatures[0]) fig, ax = subplots(figsize=(9, 9)) sns.heatmap(conf_mat_mean, ax=ax, xticklabels=sig_labels, yticklabels=sig_labels, annot=True,annot_kws={&quot;size&quot;: 9}); png 2.2.3 Performance Measures per Tissue Below, we show the Sensitiviy, Specificity and Matthews Correlation Coefficient for the different tissues. sens = performance_per_tissue(cms, sig_labels, pm.sens) spec = performance_per_tissue(cms, sig_labels, pm.spec) prec = performance_per_tissue(cms, sig_labels, pm.prec_pos) mcc = performance_per_tissue(cms, sig_labels, pm.mcc) fig, ax = subplots(figsize=(10,5)) data=pd.DataFrame(sens) sns.boxplot(data=data, ax=ax) ax.set_title(&quot;Sensitivity&quot;) ax.set_xticklabels(data.columns, rotation=90); ax.set_ylim((0, 1.1)); png fig, ax = subplots(figsize=(10,5)) data=pd.DataFrame(prec) sns.boxplot(data=data, ax=ax) ax.set_title(&quot;Precision&quot;) ax.set_xticklabels(data.columns, rotation=90); ax.set_ylim((0, 1.1)); png fig, ax = subplots(figsize=(10,5)) data=pd.DataFrame(spec) sns.boxplot(data=data, ax=ax) ax.set_title(&quot;Specificity&quot;) ax.set_xticklabels(data.columns, rotation=90); ax.set_ylim((0, 1.1)); png fig, ax = subplots(figsize=(10,5)) data=pd.DataFrame(mcc) sns.boxplot(data=data, ax=ax) ax.set_title(&quot;Matthew&#39;s correlation coefficient&quot;) ax.set_xticklabels(data.columns, rotation=90); ax.set_ylim((0, 1.1)); png Average Performance: np.mean(list(mcc.values())) 0.84104652927756762 2.3 Cross-species Cross-platform validation on mouse import sys sys.path.append(&quot;..&quot;) %load_ext autoreload %autoreload 1 %aimport pygenesig.validation %aimport pygenesig.gini %aimport pygenesig.bioqc %aimport pygenesig.perfmeasures %matplotlib inline from pygenesig.validation import * from pygenesig.gini import * from pygenesig.bioqc import * import pygenesig.perfmeasures as pm import numpy as np import pandas as pd from IPython.display import display import seaborn as sns from pylab import * We load the preprocessed GTEx dataset. The preprocessing steps are described in this notebook. expr = np.load(&quot;../data/gtex/exprs.npy&quot;) target = np.genfromtxt(&quot;../data/gtex/target.csv&quot;, delimiter=&quot;,&quot;, dtype=str) gene_symbols = pd.read_csv(&quot;../data/gtex/gene_symbols.csv&quot;, delimiter=&quot;,&quot;, dtype=str, header=None) gene_symbols.columns = [&#39;ensemble&#39;, &#39;hgnc&#39;] We load the GNF mouse dataset: human_to_mouse = pd.read_csv(&quot;../data/mouseGNF/map_orthologoues.tsv&quot;, delimiter=&quot;\\t&quot;) human_to_mouse[&#39;rowname&#39;] = human_to_mouse.index mouse_expr = pd.read_csv(&quot;../data/mouseGNF/mouseGNF-signalMatrix.gct&quot;, delimiter=&quot;\\t&quot;, skiprows=2) mouse_pdata = pd.read_csv(&quot;../data/mouseGNF/mouseGNF-phenoData.txt&quot;, delimiter=&quot;\\t&quot;) mouse_target = mouse_pdata.loc[~mouse_pdata[&quot;GEO.source.name&quot;].isnull(), &quot;GEO.source.name&quot;].apply( lambda x: &quot;_&quot;.join(x.split(&quot;_&quot;)[:-1])) mouse_expr = mouse_expr.iloc[:, 2:] # remove description and id mouse_expr = mouse_expr.values mouse_expr = mouse_expr[:, mouse_target.index] # select samples with tissue annotation. mouse_target = np.array(mouse_target) 2.3.0.1 Translation of signatures The signatures consist of the row indices of the expression matrix they were generated on. We therefore need to translate the signatures from the human dataset to the mouse dataset. This is done in the following way: GTEx indices \\(\\to\\) human gene symbols \\(\\to\\) mouse orthologous gene symbols \\(\\to\\) mouseGNF indices translation_df = pd.merge(gene_symbols, human_to_mouse, how=&#39;inner&#39;, left_on=&#39;hgnc&#39;, right_on=&#39;GeneSymbol&#39;) translation_df.set_index(&#39;hgnc&#39;, inplace=True) def translate_signatures(signatures_origin): st = {} gene_symbol_list = list(gene_symbols.hgnc) for tissue, genes in signatures_origin.items(): st[tissue] = [] for g in genes: gene_symbol = gene_symbol_list[g] try: rownames = pd.Series(translation_df.loc[gene_symbol, &quot;rowname&quot;]) st[tissue].extend(list(rownames)) except KeyError: pass return st have_orthologue = unique(pd.merge(gene_symbols, translation_df, left_on=&#39;hgnc&#39;, right_index=True).index) 2.3.1 Make Signatures sg = GiniSignatureGenerator(expr[:, :], target) signatures = sg.mk_signatures(np.array(list(range(len(target))))) signatures_mouse = translate_signatures(signatures) 2.3.2 Test Signatures st = BioQCSignatureTester(mouse_expr, mouse_target) actual, predicted = st.test_signatures(signatures_mouse, np.array(list(range(len(mouse_target)))), return_labels=True) result = pd.DataFrame({&quot;actual&quot; : actual, &quot;predicted&quot; : predicted}) confmat = pd.crosstab(result.actual, result.predicted) sig_labels = st.sort_signatures(signatures) The resulting heatmap demonstrates that the signatures we identified as ‘robust’ in the corss-validation procedure do work across multiple species and multiple experimental platforms: fig, ax = subplots(figsize=(7, 15)) sns.heatmap(confmat.as_matrix(), ax=ax, linewidths=.5, xticklabels=list(confmat.columns), yticklabels=list(confmat.index)) ax.set_xticklabels(ax.get_xticklabels(), rotation=90); png "],
["curating-data.html", "3 Curating Data 3.1 Selecting Samples by Metadata 3.2 Normalize Tissues 3.3 Map tissues to signatures", " 3 Curating Data 3.1 Selecting Samples by Metadata GEOmetadb is a SQLite database containing metadata associated with samples and studies from GEO. This database has proven to be tremendously helpful for selecting samples by tissue and organism. We integrate the database into the study’s DBS and describe how we select samples in detail in Sample selection. 3.2 Normalize Tissues The annotation of tissues is inconsistent within GEO. A “liver” sample can be termed e.g. “liver”, “liver biopsy” or “primary liver”. We therefore need a way to “normalize” the tissue name. We did this manually for the most abundant tissues in this Excel sheet. 3.3 Map tissues to signatures In order to find out which samples are ‘contamined’ by other tissues, we first need to define which signatures we would ‘expect’ in a certain tissue. We therefore manually mapped signatures to the respective tissue type in this Excel sheet. For example, we map the signatures Intestine_Colon_cecum_NR_0.7_3 and Intestine_Colon_NR_0.7_3 to colon. We mapped all normalized tissues from above to the respective signatures, which have at least 500 samples. We mapped tissues with a lower sample count only if they formed a subset of an already mapped tissue (e.g. we mapped prefrontal cortex to brain although having less than 500 samples, because we already mapped signatures to brain.) Moreover, we ran into the issue, that some tissue signatures are not as specific as the annotation in the GEO. We therefore curated so-called tissue sets to combine them into groups. For example, it is hard to distinguish jejunum from colon, but easy to distinguish the two from other tissues. We therefore created a tissue set intestine, which contains both jejunum and colon and references all signatures associated with the two tissues. This information is part of the same Excel sheet. We created a tissue set bioqc_all which maps all tissues to all signatures provided by the authors of BioQC and a high-confidence tissue-set gtex_solid which only maps tissues to signatures that we could validate as high-confidence signatures in Validate Tissue Signatures. "],
["setup-database.html", "4 Setup Database 4.1 Tables explained 4.2 Import GEOmetadb 4.3 Import BioQC data 4.4 Store results", " 4 Setup Database We store meta information for GEO samples and BioQC p-values in an Oracle 11g database. We combine the metadata from GEOmetadb with tables to store signature scores generated with BioQC and manually curated annotations. The following figure shows the database scheme used for the study as entity-relationship (ER) diagram: Figure 4.1: Entitiy relationship diagram of the BioQC database scheme. Click the here for an enlarged version. Greenish tables are imported from GEOmetadb. Yellowish tables are additional tables designed for this study. Three dots (…) indicate columns from GEOmetadb which have been omitted in the visualisation because they are not relevant for this study. 4.1 Tables explained 4.1.1 GEOmetadb BIOQC_GSM: from GEOmetadb, meta information for all Samples in GEO BIOQC_GPL: from GEOmetadb, list of all platforms (e.g. different types of microarrays) referenced in GEO. BIOQC_GSE: from GEOmetadb, list of Series (collections of samples) in GEO. 4.1.2 BioQC BIOQC_TISSUES: List of all tissues manually annotated in Normalize Tissues BIOQC_NORMALIZE_TISSUES: Stores the manually curated mapping of the original tissue name to a normalized tissue name. BIOQC_SIGNATURES: Stores gene signatures imported from a GMT file BIOQC_TISSUE_SET: Stores the manually curated mapping of tissues to ‘expected signatures’. BIOQC_RES: Stores the p-value generated with BioQC for each signature in BIOQC_SIGNATURES and each samples in BIOQC_GSM. BIOQC_BIOQC_SUCCESS: List of all studies on which we successfully ran BioQC. This serves as ‘background’ for our analysis. 4.2 Import GEOmetadb First, we need to extract a list of tables: gdb = dbConnect(SQLite(), file.path(DATA_DIR, &quot;geometabase/GEOmetadb.sqlite&quot;)) tables = dbListTables(gdb) writeLines(tables, file(file.path(DATA_DIR, &quot;geometabase/tables.txt&quot;))) Then, we use a conversion script to export the SQL schema and the tables as csv, which can be easily imported into the Oracle DBS. We adjusted the GEOmetadb schema to match Oracle datatypes. Once the tables are imported, we check if all the tables have the same number of rows: # check for consistency for(table in tables) { count.query = sprintf(&quot;select count(*) from %s&quot;, table) count.query.ora = sprintf(&quot;select count(*) from bioqc_%s&quot;, table) print(count.query) expect_equal(dbGetQuery(gdb, count.query)[[1]], dbGetQuery(mydb, tolower(count.query.ora))[[1]]) } 4.2.1 Fix foreign key constraints Unfortunately, foreign key constraints are not enabled in the GEOmetadb SQLite database. It turned out that the GEOmetadb is not entirely consistent when trying to add such constraints in Oracle. We fixed missing parent keys by adding “stub” entries to the tables. The procedure is documented in this SQL script. 4.2.2 Extract Tissue annotation The tissue annotation for each sample is hidden in the characteristics_ch1 column of the BIOQC_GSM table. Since this information is essential for our study, we parsed it into a separate column using a regular expression. The procedure is documented in this SQL script. 4.2.3 Load annotation information To run BioQC, gene symbols need to be annotated in the gene expression matrix. To retrieve gene symbols, we are aware of two feasible possibilities: the Bioconductor annotation packages (listed in GEOmetadb gpl.bioc_package) use the GEO annot_gpl files (“in general available for all GSE that are referenced by a GDS”1) To find out for which GSE in particular the latter option exists, we parsed the directory structure of the GEO ftp server: lftp -c &quot;open ftp://ftp.ncbi.nlm.nih.gov/geo/platforms/ &amp;&amp; find &amp;&amp; exit&quot; &gt; gpl_annot_ftp_tree.txt grep annot.gz gpl_annot_ftp_tree.txt | cut -d&quot;/&quot; -f5 | cut -d&quot;.&quot; -f1 &gt; gpl_annot.txt We add this information the the BIOQC_GPL table as a boolean flag indicating whether the respective platform has an annotation file. # tmp table sql = &quot;create table bioqc_gpl_annot(gpl varchar2(10) primary key, has_annot number(1))&quot; dbSendUpdate(mydb, sql) annot = read.table(&quot;db/data/gpl_annot.txt&quot;) annot = cbind(annot, rep(1, length(annot))) colnames(annot) = c(&quot;1&quot;, &quot;2&quot;) dbAppendDf(&quot;BIOQC_GPL_ANNOT&quot;, annot) # update gpl from tmp table sqlUpdateGpl = &quot; update bioqc_gpl g set has_annot = (select has_annot from bioqc_gpl_annot a where g.gpl = a.gpl)&quot; dbSendUpdate(mydb, sqlUpdateGpl) # drop tmp table sql = &quot;drop table bioqc_gpl_annot&quot; dbSendUpdate(mydb, sql) We compared the two approaches in Sample Selection. 4.2.4 Import summary statistics for each study To perform a preliminary quality control on each study we calculated the min, max, median, mean and quartiles of the expression values of each study in GEO. This process is documented in test_for_normalization.R and the projects Makefile. We import the results into the database: study_stats = data.table(read_tsv(file.path(DATA_DIR, &quot;gse_tissue_annot/study_stats.txt&quot;))) study_stats = study_stats[,GSE:=sapply(as.character(study_stats[[1]]), geoIdFromPath)] study_stats = study_stats[,GPL:=lapply(as.character(study_stats[[1]]), gplFromPath)] setcolorder(study_stats, c(8, 9, 1:7)) study_stats[, &#39;filename&#39;] = NULL # remove file name dbSendUpdate(mydb, &quot;truncate table bioqc_tmp_gse_gpl&quot;) dbAppendDf(&quot;BIOQC_TMP_GSE_GPL&quot;, study_stats) dbSendUpdate(mydb, &quot;update bioqc_gse_gpl a set (study_mean, study_min, study_25, study_median, study_75, study_max) = (select study_mean, study_min, study_25, study_median, study_75, study_max from bioqc_tmp_gse_gpl b where a.gse = b.gse and (a.gpl = b.gpl or b.gpl is NULL))&quot;) 4.3 Import BioQC data We install the BioQC schema using this SQL script. 4.3.1 Signatures Import signatures into the database and create a single, consolidated gmt file. # Signatures shipped with BioQC (updated version from 2016-12-08) # download.file(&quot;http://bioinfo.bas.roche.com:8080/apps/gsea/genesets/exp.tissuemark.bioqc.roche.symbols.gmt&quot;, # &quot;data/expr.tissuemark.affy.roche.symbols.gmt&quot;) gmt2db(file.path(DATA_DIR, &quot;expr.tissuemark.affy.roche.symbols.gmt&quot;)) # control signatures generated from GTEx using *pygenesig* gmt2db(&quot;../pygenesig/results/gtex_ngs_0.7_3.gmt&quot;) gmt2db(&quot;../pygenesig/results/gtex_ngs_0.85_5.gmt&quot;) # baseline signatures (random/housekeeping) gmt2db(&quot;../pygenesig/results/baseline_signatures.gmt&quot;) # pathway gene sets not relevant for this study # gmt2db(&quot;../BioQC_correlated-pathways/go.bp.roche.symbols.gmt.uniq&quot;) # gmt2db(&quot;../BioQC_correlated-pathways/MetaBase.downstream.expression.gmt&quot;) # gmt2db(&quot;../BioQC_correlated-pathways/path.ronet.roche.symbols.gmt.ascii&quot;) # save imported signatures to consolidated gmt file db2gmt(&quot;results/gmt_all.gmt&quot;) 4.3.2 Tissue Annotation Import the manually curated tissues from Excel into the database. normalized_tissues = data.table(read_excel(&quot;manual_annotation/tissue_annotation.xlsx&quot;, sheet = 1)) tissues = unique(normalized_tissues[!is.na(TISSUE_NORMALIZED),&quot;TISSUE_NORMALIZED&quot;, with=FALSE]) tab_normalized = normalized_tissues[!is.na(TISSUE_NORMALIZED),c(&quot;TISSUE&quot;, &quot;TISSUE_NORMALIZED&quot;), with=FALSE] dbAppendDf(&quot;BIOQC_TISSUES&quot;, tissues) dbAppendDf(&quot;BIOQC_NORMALIZE_TISSUES&quot;, tab_normalized) 4.3.3 Tissue Sets Import the manually curated tissue sets from Excel into the database. bioqc_all = read_excel(&quot;manual_annotation/tissue_annotation.xlsx&quot;, sheet = 3) gtex_all = read_excel(&quot;manual_annotation/tissue_annotation.xlsx&quot;, sheet = 4) gtex_solid = read_excel(&quot;manual_annotation/tissue_annotation.xlsx&quot;, sheet = 5) signatureset2db(bioqc_all, &quot;bioqc_all&quot;) signatureset2db(gtex_solid, &quot;gtex_solid&quot;) signatureset2db(gtex_all, &quot;gtex_all&quot;) 4.3.4 BioQC results Once we ran the analysis, we manually import the list of samples on which we successfully applied BioQC and the respective p-values into the tables BIOQC_BIOQC_SUCCESS and BIOQC_RES: bioqc_melt_all.uniq.tsv bioqc_success.txt 4.4 Store results We do not only use the database as pure data storage, but also as data analysis engine, harvesting the power of SQL. (See sections sample selection and contamination analysis). We save intermediate results of time-consuming queries in so-called materialized views, which are pysical snapshots of a query’s result. https://bioconductor.org/packages/release/bioc/manuals/GEOquery/man/GEOquery.pdf↩ "],
["sample-selection.html", "5 Sample Selection and processing 5.1 Sample Preselection 5.2 Sample Processing with BioQC 5.3 Sample Post-selection", " 5 Sample Selection and processing 5.1 Sample Preselection Here, we document the sample selection process before running BioQC. 5.1.1 Required annotation A sample is usable for this study, if the gene symbos are annotated (requirement to run BioQC) the tissue of origin is annotated (requirment to draw conclusions about contamination) We consider two approaches for annotating gene symbols: Using the Bioconductor AnnotationDbi package. The GEOmetadb provides a mapping of the GPL identifier to these packages. Using the annotGPL=TRUE option of GEOquery’s getGEO. This requires an annotation file being available for the respective platform. We retrieved a list of the available annoataion files in an earlier step. We compare the two methods with respect to the amount of usable samples that we can get. First we need to run the sql-script annotation_stats which will create views summarizing the amount of usable samples. From these views, we can calculate a Venn diagram: The getGEO method appears to be the more powerful method. Ideal would be a combination of the two, however, for the sake of simplicity, we stick to getGEO, loosing 499 studies (35602 samples). This leaves us with the following filtering result: comment GSM GSE total 1945417 73719 tissue annotated 760798 24267 annotation file available 768346 31579 tissue and annotation file 275206 9632 5.1.2 Export list of samples We store the respective gse identifiers in results/gse_lists/gse_tissue_annotation.txt: sqlGse = &quot; select distinct gse from ( select * from bioqc_studies_has_tissue intersect select * from bioqc_studies_has_annot) u&quot; gse = dbGetQuery(mydb, sqlGse) writeLines(gse$GSE, file(gse.file)) 5.2 Sample Processing with BioQC The following processes are ressource intensive, therefore we execute them on a high performance cluster (HPC). We use chunksub to distribute the list of sample ids to the workers. This involves four major steps which are also documented in the project’s Makefile. We download the studies with GEOquery and store them as R ExpressionSet using the R script geo_to_eset.R. For some series, the download is not successful. We annotated human orthologous genes for all studies using ribiosAnnotation in annotate_eset.R. This is necessary as the tissue signatures are built on a human dataset. The annotation failes for species which are not in the ribios database. We run BioQC on these studies use run_bioqc.R. Finally, we prefilter BioQC’s results for having a p-value &lt; 0.05 and import them into the database. 5.3 Sample Post-selection The failures during download and annotation reduce the number of samples available to our study. sql_select = &quot; select /*+ USE_HASH(bs, bgg) parallel(16) */ count(distinct bg.gsm) as GSM , count(distinct bgg.gse) as GSE&quot; sql_from = &quot; from bioqc_bioqc_success bs join bioqc_gsm bg on bg.gsm = bs.gsm join bioqc_gse_gsm bgg on bgg.gsm = bs.gsm &quot; sql_where = &quot;&quot; res = dbGetQuery(mydb, str_c(sql_select, sql_from, sql_where, sep=&quot;\\n&quot;)) kable(res) GSM GSE 253210 8083 5.3.1 Excluding multi-channel microarrays Multi channel microarrays date back to the early age of gene expression studies. They don’t provide absolute gene expression data and are not meaningful outside their experimental context. We therefore exclude these experiments: sql_select2 = sql_select sql_from2 = sql_from sql_where2 = str_c(sql_where, &quot;where channel_count = 1&quot;, sep=&quot;\\n&quot;) res = dbGetQuery(mydb, str_c(sql_select2, sql_from2, sql_where2, sep=&quot;\\n&quot;)) kable(res) GSM GSE 235237 7561 5.3.2 Exclude non-mapped tissues We exclude samples that have a tissue annotated, but it is not mapped to a normalized tissue. sql_select3 = sql_select2 sql_from3 = str_c(sql_from2, &quot; join bioqc_normalize_tissues bnt on bnt.tissue_orig = lower(bg.tissue_orig)&quot;, sep=&quot;\\n&quot;) sql_where3 = sql_where2 res = dbGetQuery(mydb, str_c(sql_select3, sql_from3, sql_where3, sep=&quot;\\n&quot;)) kable(res) GSM GSE 135670 3770 5.3.3 Select organisms We were interested in the organism distribution. sql_select4 = str_c(sql_select3, &quot;, bg.organism_ch1&quot;, sep=&quot;\\n&quot;) sql_from4 = sql_from3 sql_where4 = sql_where3 res = dbGetQuery(mydb, str_c(sql_select4, sql_from4, sql_where4, &quot; group by organism_ch1 order by gsm desc&quot;, sep=&quot;\\n&quot;)) kable(res) GSM GSE ORGANISM_CH1 65769 1201 Homo sapiens 38096 2267 Mus musculus 29909 278 Rattus norvegicus 1082 24 Macaca mulatta 259 7 Macaca fascicularis 202 2 Mus musculus musculus x M. m. domesticus 80 2 Cercocebus atys 57 1 Oryctolagus cuniculus 36 1 Chlorocebus aethiops 32 3 Mus musculus domesticus 25 1 Pan troglodytes 23 1 Papio cynocephalus 19 1 Mus spretus 18 1 Capra hircus 16 1 Phodopus sungorus 12 1 Mus musculus musculus x M. m. castaneus 12 1 Papio hamadryas 8 1 Macaca nemestrina 6 1 Mus musculus castaneus 6 1 Mus musculus musculus 3 1 Mus sp. Results suggest that it makes sense to limit the analysis to the three main organisms: H. sapiens, M. musculus, R. norvegicus. This makes also sense as these species are closesly related and therefore the signatures are more likely to translate within these species. We are left with the following amount of samples: sql_select5 = sql_select3 sql_from5 = sql_from4 sql_where5 = str_c(sql_where4, &quot; and organism_ch1 in (&#39;Homo sapiens&#39;, &#39;Mus musculus&#39;, &#39;Rattus norvegicus&#39;)&quot;, sep=&quot;\\n&quot;) res = dbGetQuery(mydb, str_c(sql_select5, sql_from5, sql_where5, sep=&quot;\\n&quot;)) kable(res) GSM GSE 133774 3727 5.3.4 Quality control In this step we seek to identify studies on which BioQC cannot work due to poor data quality or data processing steps that remove the relative expression of a gene within a sample, e.g. per-gene normalization. We will first filter samples by applying a cutoff-value to statistics on the gene expression data. Second, we will use an ubiquitous signature containing housekeeping genes as an indicator if BioQC returns a sensible result on the given sample. On each study, we have calculated the mean of each gene over all samples. Of this series of means, we calculate the IQR. If a per-gene normalization has been applied, this value should be close to zero. This histogram shows a distribution of all IQRs over all remaining studies: sql_select_hist = &quot; select /*+ USE_HASH(bs, bgg) parallel(16) */ distinct bgg.gse , study_median , abs(study_75-study_25) as IQR &quot; sql_from_hist = str_c(sql_from5, &quot; join bioqc_gse_gpl bgl on bgg.gse = bgl.gse and bg.gpl = bgl.gpl&quot;, sep=&quot;\\n&quot;) sql_where_hist = sql_where5 res = dbGetQuery(mydb, str_c(sql_select_hist, sql_from_hist, sql_where_hist, sep=&quot;\\n&quot;)) sm = res$IQR hist(sm[sm &gt; 0 &amp; sm &lt; 25], breaks=seq(0, 25, .25), main=&quot;Variance between gene for each study (IQR)&quot;, xlab=&quot;median gene expression (only values up to 25)&quot;) abline(v=.5, col=&quot;blue&quot;) minor.tick(nx=5) We exclude all studies having a very low variance between genes (IQR &lt; 0.5). Remaining samples: sql_select6 = sql_select3 sql_from6 = str_c(sql_from5, &quot; join bioqc_gse_gpl bgl on bgg.gse = bgl.gse&quot;, sep=&quot;\\n&quot;) sql_where6 = str_c(sql_where5, &quot; and abs(study_75 - study_25) &gt;= .5&quot;, sep=&quot;\\n&quot;) res = dbGetQuery(mydb, str_c(sql_select6, sql_from6, sql_where6, sep=&quot;\\n&quot;)) kable(res) GSM GSE 95591 3103 Now, we have a look at the p-value distribution of the signature we called awesome_housekeepers containing ubiquitous genes. The gene expression of these genes can be assumed to be more or less constant over all tissue types, therefore this signature should score high in every sample. Awesome Housekeepers The orange curve is the pvalue distribution of the housekeeping signature. The blue curve shows the distribution of a random control signature containing 100 randomly chosen genes. sql_select_hk = &quot; select /*+ USE_HASH(bs, bgg) parallel(16) */ br.signature , br.pvalue , bs.name &quot; sql_from_hk = str_c(sql_from6, &quot; join bioqc_res br on br.gsm = bg.gsm join bioqc_signatures bs on bs.id = br.signature&quot;, sep=&quot;\\n&quot;) sql_where_hk = str_c(sql_where6, &quot; and br.signature in (54911, 54933) -- awesome_housekeepers, random_100_0&quot;) res = data.table(dbGetQuery(mydb, str_c(sql_select_hk, sql_from_hk, sql_where_hk, sep=&quot;\\n&quot;))) invisible(res[,SCORE:=absLog10p(as.numeric(PVALUE))]) ggplot(res, aes(x=SCORE)) + geom_density(aes(color=NAME)) + geom_vline(xintercept = 5, color=&quot;blue&quot;) + theme(legend.position = &quot;top&quot;) We exclude all samples for which awesome_housekeepers scores with &lt; 5, i.e. pvalue &gt;= 1e-5. sql_select7 = sql_select6 sql_from7 = str_c(sql_from6, &quot; join bioqc_res br on br.gsm = bg.gsm&quot;, sep=&quot;\\n&quot;) sql_where7 = str_c(sql_where6, &quot; and signature = 54911 and pvalue &lt; 1e-5&quot;, sep=&quot;\\n&quot;) res = dbGetQuery(mydb, str_c(sql_select7, sql_from7, sql_where7, sep=&quot;\\n&quot;)) kable(res) GSM GSE 81426 2902 This is the ‘background’ of samples on which we test for tissue contamination. We store the selected samples alongside with meta information required for the analysis in the materialized view BIOQC_SELECTED_SAMPLES in our DBS. Here is the SQL script generating the materialized view. 5.3.5 Tissue abundance The following table shows how many samples are available for each tissue: sqlTissue = &quot; select /*+ parallel(16) */ tissue, count(distinct gsm) as samples from bioqc_selected_samples group by tissue order by samples desc&quot; resTissue = dbGetQuery(mydb, sqlTissue) kable(resTissue) TISSUE SAMPLES blood 18064 liver 12925 lung 7586 bone marrow 3911 kidney 3540 breast tumor 3465 brain 3452 heart 2402 spleen 2302 adipose 2214 skin 1927 skeletal muscle 1830 hippocampus 1573 colon 1463 lymph node 1120 cerebellum 1094 hepatocyte 1094 tumor 1036 breast 795 frontal cortex 729 placenta 678 pbmc 665 white blood cells 664 testis 627 retina 596 pancreas 586 thymus 551 pancreatic islets 488 ovary 455 mammary gland 395 jejunum 380 prostate 330 hypothalamus 271 cortex 256 prefrontal cortex 249 uterus 232 embryo 217 stomach 127 bladder 123 cervix 95 ventral midbrain 74 eye 69 salivary gland 48 neuroblastoma 45 adrenal gland 39 monocyte 6 "],
["contamination-analysis.html", "6 Analyse Contamination 6.1 Input Tables 6.2 Processing Steps explained", " 6 Analyse Contamination The heartpiece of the study is this sql script which identifies heterogenous samples. In this section we will go through the different analysis steps performed in the script. 6.1 Input Tables BIOQC_SELECTED_SAMPLES: the samples resulting from the selection process including metadata BIOQC_TISSUE_SET: the manual mapping of tissues to signatures (“expected signatures”) BIOQC_RES: the p-values for each sample and signature (pre-filtered for having a p-value &lt; 0.05) 6.2 Processing Steps explained 6.2.1 BIOQC_SELECTED_SAMPLES_TSET We join BIOQC_SELECTED_SAMPLES on BIOQC_TISSUE_SET to attach the tissue group and the respective signatures to each sample. Example: The table rows for the colon sample GSM1234 could look like: GSM TISSUE TISSUE_SET TGROUP EXP_SIGNATURE EXP_SIGNATURE_NAME GSM1234 colon gtex_all colon 543 Colon GSM1234 colon gtex_solid intestine 543 Colon GSM1234 colon gtex_solid intestine 544 Jejunum 6.2.2 BIOQC_RES_TSET We join the BioQC results (pvalue for each signature and sample) from BIOQC_RES with BIOQC_TISSUE_SET to map the signatures back to their tissue group. Example: For a result GSM SIGNATURE PVALUE GSM1234 544 1e-10 GSM1234 543 1e-5 the table rows could look like GSM FOUND_SIG PVALUE FOUND_SIG_NAME FOUND_TGROUP TISSUE_SET GSM1234 544 1e-10 Jejunum jejunum gtex_all GSM1234 544 1e-10 Jejunum intestine gtex_solid GSM1234 543 1e-5 Colon colon gtex_all GSM1234 543 1e-5 Colon intestine gtex_solid 6.2.3 BIOQC_TISSUE_ENRICHMENT We now match the found onto the expected tissue groups by joining BIOQC_SELECTED_SAMPES_TSET with BIOQC_RES_TSET on GSM and TISSUE_SET. We calculate the Enrichment Ratio as \\(\\log_{10}(p_{expected\\_sig} / p_{found\\_sig})\\). For the above example tables, we would get: GSM TISSUE TISSUE_SET TGROUP EXP_SIGNATURE EXP_SIGNATURE_NAME FOUND_SIG FOUND_SIG_NAME ENRICHMENT_RATIO GSM1234 colon gtex_all colon 543 Colon 543 Colon 0.0 GSM1234 colon gtex_all colon 543 Colon 544 Jejunum 5.0 ... We filter out rows where the found signature is in the list of expected sigantures for the respective tissue group: GSM TISSUE TISSUE_SET TGROUP EXP_SIGNATURE EXP_SIGNATURE_NAME FOUND_SIG FOUND_SIG_NAME ENRICHMENT_RATIO GSM1234 colon gtex_all colon 543 Colon 544 Jejunum 5.0 ... 6.2.4 BIOQC_TISSUE_ENRICHMENT2 combine expected signature by taking the minimal enrichment ratio for each expected signature. Example: GSM TISSUE TGROUP EXPECTED FOUND ENRICHMENT_RATIO GSM888 jejunum intestine colon liver_fetal 12 GSM888 jejunum intestine colon liver 8 GSM888 jejunum intestine jejunum liver_fetal 5 GSM888 jejunum intestine jejunum liver 4 will be combined into GSM TGROUP EXPECTED FOUND ENRICHMENT_RATIO RANK GSM888 intestine liver_fetal 5 1 GSM888 intestine liver 4 1 if multiple infiltrating tissues are found, a rank is calculated. 6.2.5 BIOQC_CONTAM_STATS Add year, country and organism to each sample from BIOQC_TISSUE_ENRICHMENT2. 6.2.6 BIOQC_TISSUE_MIGRATION Add origin and destination tissue groups for each sample by mapping the found signatures back to tissue groups. Example: GSM TISSUE_SET ORIGIN FOUND_SIG FOUND_SIG_NAME ENRICHMENT_RATIO DESTINATION GSM1234 gtex_all colon 544 Jejunum 5 jejunum "],
["tissue-migration.html", "7 Tissue Migration", " 7 Tissue Migration Now, detect samples we defined as contamined: * highly siginificant BioQC scores (min score per sample &gt;6) * signature outside ‘expected’ signature that is at least 6 higher than the highest score in expected signatures. * (outlier in study) We can find contamined studies with SQL only. To speed up things, we create a temporary table (rather a materialized view, but that’s not available on our old postgres server) filtering for samples, where a non-expected signature exceeds all expected signatures by a certain threshold (BioQC score &gt; 6, aka. ‘enrichment-ratio’). This table is created in db/queries/mk-extended_bioqc_res_table2.sql. We create a view contamined_samples that contains all contamined samples in db/queries/get_contamined_samples.sql. Second, we retrieve the information we need for the migration chart from that temporary table. query = &quot; select origin , destination , count(gsm) as \\&quot;count\\&quot; from bioqc_tissue_migration where enrichment_ratio &gt; 4 and rk = 1 and tissue_set = &#39;bioqc_all&#39; group by origin, destination order by origin, destination&quot; migration = dbGetQuery(mydb, query) set.seed(42) col = rand_color(length(unique(migration$ORIGIN))) names(col) = unique(migration$ORIGIN) chordDiagram(migration, grid.col=col, annotationTrack=&quot;grid&quot;, preAllocateTracks=1) circos.trackPlotRegion(track.index=1, panel.fun = function(x, y) { xlim = get.cell.meta.data(&quot;xlim&quot;) ylim = get.cell.meta.data(&quot;ylim&quot;) sector.name = get.cell.meta.data(&quot;sector.index&quot;) circos.text(mean(xlim), ylim[1] + .1, sector.name, facing = &quot;clockwise&quot;, niceFacing = TRUE, adj = c(0, 0.5)) circos.axis(h = &quot;top&quot;, labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 2) }, bg.border = NA) 7.0.1 same with ‘gtex_solid’ signatures query = &quot; select origin , destination , count(gsm) as \\&quot;count\\&quot; from bioqc_tissue_migration where enrichment_ratio &gt; .2 and rk = 1 and tissue_set = &#39;gtex_solid&#39; group by origin, destination order by origin, destination&quot; migration = dbGetQuery(mydb, query) set.seed(42) col = rand_color(length(unique(migration$ORIGIN))) names(col) = unique(migration$ORIGIN) chordDiagram(migration, grid.col=col, annotationTrack=&quot;grid&quot;, preAllocateTracks=1) circos.trackPlotRegion(track.index=1, panel.fun = function(x, y) { xlim = get.cell.meta.data(&quot;xlim&quot;) ylim = get.cell.meta.data(&quot;ylim&quot;) sector.name = get.cell.meta.data(&quot;sector.index&quot;) circos.text(mean(xlim), ylim[1] + .1, sector.name, facing = &quot;clockwise&quot;, niceFacing = TRUE, adj = c(0, 0.5)) circos.axis(h = &quot;top&quot;, labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 2) }, bg.border = NA) chordDiagram(migration[migration$ORIGIN != &#39;blood&#39; &amp; migration$DESTINATION!=&#39;blood&#39;,]) Contamination in total: byTissue = &quot; with contam_stats as ( select bcs.* , case when enrichment_ratio &gt; .2 then 1 else null end as is_contam from bioqc_contam_stats bcs ) select tgroup , count(gsm) as total , count(is_contam) as contamined , count(is_contam)/cast(count(gsm) as float) as ratio from contam_stats where tissue_set = &#39;gtex_solid&#39; group by tgroup order by ratio desc &quot; tissue = data.table(dbGetQuery(mydb, byTissue)) tissue[,TGROUP:=factor(TGROUP, levels=TGROUP)] ggplot(data=tissue, aes(x=TGROUP, y=RATIO)) + geom_bar(stat=&quot;identity&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) We can also compose statistics about the origin of samples By time byYear = &quot; with contam_stats as ( select bcs.* , case when enrichment_ratio &gt; 4 then 1 else null end as is_contam from bioqc_contam_stats bcs ) select year , tgroup , count(gsm) as total , count(is_contam) as contamined , count(is_contam)/cast(count(gsm) as float) as ratio from contam_stats where tissue_set = &#39;gtex_solid&#39; group by year, tgroup order by ratio desc &quot; year = dbGetQuery(mydb, byYear) ggplot(data=year, aes(x=YEAR, y=RATIO)) + stat_summary(fun.y=&quot;mean&quot;, geom=&quot;bar&quot;) By organism byOrganism = &quot; with contam_stats as ( select bcs.* , case when enrichment_ratio &gt; 4 then 1 else null end as is_contam from bioqc_contam_stats bcs ) select organism , tgroup , count(gsm) as total , count(is_contam) as contamined , count(is_contam)/cast(count(gsm) as float) as ratio from contam_stats where tissue_set = &#39;gtex_solid&#39; group by organism, tgroup order by ratio desc &quot; organism = dbGetQuery(mydb, byOrganism) tissues = c(&quot;blood&quot;, &quot;brain&quot;, &quot;kidney&quot;, &quot;liver&quot;) organism.2 = organism[organism$TGROUP %in% tissues, ] #ggplot(data=organism.2, aes(x=ORGANISM, y=RATIO)) + stat_summary(fun.y=&quot;mean&quot;, geom=&quot;bar&quot;) ggplot(data=organism.2, aes(x=ORGANISM, y=RATIO)) + geom_boxplot() + geom_point(aes(color=TGROUP)) "]
]
