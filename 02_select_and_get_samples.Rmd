---
title: Data preparation for Analysing GEO Samples for contamination. 
output: 
  html_document: default
---

```{r setup, include=FALSE}
source("lib/knitr.R")
library(BioQC)
library(rworldmap)
library(VennDiagram)
library(data.table)
library(grid)
library(gridBase)
library(stringr)
library(testthat)
source("lib/plots.R")
source("lib/db.R")
```

Here, we document the sample selection process. 

## Selecting samples that have the required annotation
A sample is usable for use, if 

* the gene symbos are annotated (requirement to run BioQC)
* the tissue of origin is annotated (requirment to draw conclusions about contamination)

We consider two approaches for annotating gene symbols: 

* Using the Bioconductor [AnnotationDbi](https://bioconductor.org/packages/release/bioc/html/AnnotationDbi.html) package. The GEOmetadb provides a mapping of the GPL identifier to these packages. 
* Using the `annotGPL=TRUE` option of [GEOquery](https://bioconductor.org/packages/release/bioc/html/GEOquery.html)'s `getGEO`. This requires an annotation file being available for the respective platform. We retrieved a list of the available annoataion files in an earlier step. 

We compare the two methods with respect to the amount of usable samples that we can get: 
 
Run sql script
`views/annotation_stats.sql`.
 
```{r sample_filtering, cache=TRUE, fig.width=8, fig.height=3}
# filtering stats for a table. 
sqlStats = "
select 'total', count(distinct gsm), count(distinct gse) from bioqc_studies_total
union select 'tissue', count(distinct gsm), count(distinct gse) from bioqc_studies_has_tissue
union select 'package', count(distinct gsm), count(distinct gse) from bioqc_studies_has_package
union select 'annotation', count(distinct gsm), count(distinct gse) from bioqc_studies_has_annot
union select 'tissue_package', count(distinct gsm), count(distinct gse) from (select * from bioqc_studies_has_tissue intersect select * from bioqc_studies_has_package) u1
union select 'annotation_package', count(distinct gsm), count(distinct gse) from (select * from bioqc_studies_has_annot intersect select * from bioqc_studies_has_package) u2
union select 'tissue_annotation', count(distinct gsm), count(distinct gse) from (select * from bioqc_studies_has_tissue intersect select * from bioqc_studies_has_annot) u3
union select 'annotation_tissue_package', count(distinct gsm), count(distinct gse) from (select * from bioqc_studies_has_tissue intersect select * from bioqc_studies_has_package intersect select * from bioqc_studies_has_annot) u4
"
stats = data.table(dbGetQuery(mydb, sqlStats))
colnames(stats) = c("rn", "GSM", "GSE")
setkey(stats,rn)

categories = c("tissue", "annot pkg", "annot GPL")
colors=c('red', 'green', 'blue')

plot.new()
gl = grid.layout(nrow=1, ncol=2)
vp.1 = viewport(layout.pos.col=1, layout.pos.row=1)
vp.2 = viewport(layout.pos.col=2, layout.pos.row=1)
pushViewport(viewport(layout=gl))
pushViewport(vp.1)

draw.triple.venn(stats[rn=='tissue',GSM], 
                 stats[rn=='package',GSM], 
                 stats[rn=='annotation',GSM], 
                 stats[rn=='tissue_package',GSM],
                 stats[rn=='annotation_package',GSM], 
                 stats[rn=='tissue_annotation',GSM], 
                 stats[rn=='annotation_tissue_package',GSM], category=categories, fill=colors)

popViewport()
pushViewport(vp.2)

draw.triple.venn(stats[rn=='tissue',GSE], 
                 stats[rn=='package',GSE], 
                 stats[rn=='annotation',GSE], 
                 stats[rn=='tissue_package',GSE],
                 stats[rn=='annotation_package',GSE], 
                 stats[rn=='tissue_annotation',GSE], 
                 stats[rn=='annotation_tissue_package',GSE], category=categories, fill=colors)

popViewport(1)
```

The `getGEO` method appears to be the more powerful method. Ideal would be a combination of the two, however, for the sake of simplicity, we stick to `getGEO`, loosing `r as.integer(stats[rn=="tissue_package",GSE]-stats[rn=="annotation_tissue_package",GSE])` studies (`r as.integer(stats[rn=="tissue_package",GSM]-stats[rn=="annotation_tissue_package",GSM])` samples). 

This leaves us with the following filtering result: 
```{r sample_filtering2, cache=TRUE}
tab = stats[.(c("total", "tissue", "annotation", "tissue_annotation"))]
tab = tab[,comment:=c("total", "tissue annotated", "annotation file available", "tissue and annotation file")]
kable(tab[,c("comment","GSM","GSE"),with=FALSE])
```

We store the respective gse identifiers in ``r gse.file = "results/gse_tissue_annotation.txt"; gse.file``. 
```{r sample_filtering_out, cache=TRUE}
sqlGse = "select distinct gse from (select * from bioqc_studies_has_tissue intersect select * from bioqc_studies_has_annot) u"
gse = dbGetQuery(mydb, sqlGse)
writeLines(gse$GSE, file(gse.file))
```


## Processing samples with BioQC

1. We download the studies with [`GEOquery`](https://bioconductor.org/packages/release/bioc/html/GEOquery.html) in `scripts/geo_to_eset.R`. Some studies fail to download. 
2. We run BioQC on these studies with `scripts/run_bioqc.R`. This process involves annotation the human orthologous genes for studies from different species. This is done using `ribiosAnnotation`. The annotation failes for species that are not in the ribios database. 
3. We import the BioQC results into our database with `scripts/bioqc2db.R`. The import failes for studies that reference samples that are not in GEOmetadb

After failures, we are left with the following number of studies/samples:

```{r after_failures}
# since there are muliple gpl and gsm in a gse, there might've been some gsm inserted, that don't have 
# a tissue annotated, albeit the gse was selected. 
sqlFilter = "
select /*+ parallel(16) */ count(distinct bioqc_res.gsm) as GSM, count(distinct bioqc_res.gse) as GSE from bioqc_res 
join bioqc_gsm bg on bg.gsm = bioqc_res.gsm
where bg.tissue is not null and bg.tissue != 'other'"
res = dbGetQuery(mydb, sqlFilter)
kable(res)
```

Although we lost a considerable amount of studies, we only lost a few samples. Apparently, the respective studies were relatively small. 
<!-- i also found empty studies -->

## Excluding multi channel microarrays

Multi channel microarrays date back to the early age of gene expression studies. They don't provide absolute gene expression data and are not meaningful outside their experimental context. We therefore exclude these experiments
```{r exclude_multichannel}
sqlFilter = str_c(sqlFilter, "and channel_count = 1", sep="\n")
res = dbGetQuery(mydb, sqlFilter)
kable(res)
```

## Organism selection. 
We were interested in the organism distribution.
```{r filter_orga}
sqlOrga = "
select /*+ parallel(16) */  count(distinct bioqc_res.gsm) as GSM
                          , count(distinct bioqc_res.gse) as GSE 
                          , bg.organism_ch1
from bioqc_res 
join bioqc_gsm bg on bg.gsm = bioqc_res.gsm
where bg.tissue is not null and bg.tissue != 'other'
and channel_count = 1
group by organism_ch1
order by gsm desc"
res = dbGetQuery(mydb, sqlOrga)
kable(res)
```

Results suggest that it makes sense to limit the samples to the three main organisms: *H. sapiens*, *M. musculus*, *R. norvegicus*. This makes also sense as these species are closesly related and therefore the signatures are more likely to translate within these species. 
We are left with the following amount of samples: 

```{r filter_orga2}
sqlFilter = str_c(sqlFilter, "and organism_ch1 in ('Homo sapiens', 'Mus musculus', 'Rattus norvegicus')", sep="\n")
res = dbGetQuery(mydb, sqlFilter)
kable(res)
```

We create a materialized view `BIOQC_RES_FIL` with bioqc results that are filted according 
to these criteria in `db/views/bioqc_res_fil.sql`. Make sure the results are identical: 
```{r test_view}
sqlTest = "select /*+ parallel(16) */ count(distinct gsm) from bioqc_res_fil"
resTest = dbGetQuery(mydb, sqlTest)
expect_equal(res$GSM, resTest[1,1])
```


## Tissue selection
Number of samples per tissue:
```{r tissues}
sqlTissue = "
select /*+ parallel(16) */ tissue, count(distinct gsm) as samples from bioqc_res_fil
group by tissue
order by samples desc"
resTissue = dbGetQuery(mydb, sqlTissue)
kable(resTissue)
```


## Subsampling per study. 
Random subsampling?
How many samples per study? 