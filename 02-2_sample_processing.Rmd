## Processing Samples with BioQC

```{r setup, include=FALSE}
source("lib/knitr.R")
library(BioQC)
library(rworldmap)
library(VennDiagram)
library(data.table)
library(grid)
library(gridBase)
library(stringr)
library(testthat)
source("lib/plots.R")
source("lib/db.R")
```

The following processes are ressource intensive, therefore we execute them on high performance cluster (HPC). We use [chunksub](https://github.com/grst/chunksub) to distribute the [list of sample ids](#sample-list) to the workers. This involves four major steps which are also documented in the project's [Makefile](https://github.com/grst/BioQC_GEO_analysis/blob/master/Makefile). 

1. We download the studies with [GEOquery](https://bioconductor.org/packages/release/bioc/html/GEOquery.html) and store them as R [ExpressionSet](https://bioconductor.org/packages/devel/bioc/vignettes/Biobase/inst/doc/ExpressionSetIntroduction.pdf) using [geo_to_eset.R](https://github.com/grst/BioQC_GEO_analysis/blob/master/scripts/geo_to_eset.R). For some packages, the download is not successful. 
2. We annotated human orthologous genes for all studies using [ribiosAnnotation](https://github.com/Accio/ribios) in [annotate_eset.R](https://github.com/grst/BioQC_GEO_analysis/blob/master/scripts/annotate_eset.R). This is necessary as the tissue signatures are built on a human dataset. The annotation failes for species which are not in the `ribios` database. 
3. We run *BioQC* on these studies use [run_bioqc.R](https://github.com/grst/BioQC_GEO_analysis/blob/master/scripts/run_bioqc.R). 
4. Finally, we prefilter BioQC's results for having a p-value of at most 0.05 and import them into the database. 


After failures / insignificant pvalue, we are left with the following number of studies/samples:

```{r after_failures, cache=TRUE}
# since there are muliple gpl and gsm in a gse, there might've been some gsm inserted, that don't have 
# a tissue annotated, albeit the gse was selected. 
sql = "
select /*+ USE_HASH(br, bg, bnt, bgg) parallel(16) */ count(distinct bgg.gsm) as GSM
                                                    , count(distinct bgg.gse) as GSE
from bioqc_res_tissue br
join bioqc_gsm bg
  on bg.gsm = br.gsm
left outer join bioqc_gse_gsm bgg
  on bgg.gsm = br.gsm
"
sql_where = "where bg.tissue_orig is not NULL"
res = dbGetQuery(mydb, str_c(sql, sql_where, sep="\n"))
kable(res)
```

Although we lost a considerable amount of studies, we only lost a few samples. Apparently, the respective studies were relatively small. 
<!-- i also found empty studies -->

## Excluding multi channel microarrays

Multi channel microarrays date back to the early age of gene expression studies. They don't provide absolute gene expression data and are not meaningful outside their experimental context. We therefore exclude these experiments
```{r exclude_multichannel, cache=TRUE}
sql_where2 = str_c(sql_where, "and channel_count = 1", sep="\n")
res = dbGetQuery(mydb, str_c(sql, sql_where2, sep="\n"))
kable(res)
```

Exclude samples that have a tissue that has not been normalized. 

```{r normalize_tissue, cache=TRUE}
# replace join on 'has_tissue' with join on 'normalize_tissue'
sql = "
select /*+ USE_HASH(br, bg, bnt, bgg) parallel(16) */ count(distinct br.gsm)  as GSM
                                                    , count(distinct bgg.gse) as GSE 
from bioqc_res_tissue br
join bioqc_gsm bg
  on bg.gsm = br.gsm
join bioqc_normalize_tissues bnt
  on bnt.tissue_orig = lower(bg.tissue_orig)
left outer join bioqc_gse_gsm bgg
  on bgg.gsm = br.gsm
where channel_count = 1
"
res = dbGetQuery(mydb, sql)
kable(res)
```

## Organism selection. 
We were interested in the organism distribution.
```{r filter_orga, cache=TRUE}
sql_orga = "
select /*+ USE_HASH(br, bg, bnt, bgg) parallel(16) */ count(distinct br.gsm)  as GSM
                                                    , count(distinct bgg.gse) as GSE 
                                                    , bg.organism_ch1
from bioqc_res_tissue br
join bioqc_gsm bg
  on bg.gsm = br.gsm
join bioqc_normalize_tissues bnt
  on bnt.tissue_orig = lower(bg.tissue_orig)
left outer join bioqc_gse_gsm bgg
  on bgg.gsm = br.gsm
where channel_count = 1
group by organism_ch1
order by gsm desc"
res = dbGetQuery(mydb, sql_orga)
kable(res)
```

Results suggest that it makes sense to limit the samples to the three main organisms: *H. sapiens*, *M. musculus*, *R. norvegicus*. This makes also sense as these species are closesly related and therefore the signatures are more likely to translate within these species. 
We are left with the following amount of samples: 

```{r filter_orga2, cache=TRUE}
sql_orga2 = str_c(sql, "and organism_ch1 in ('Homo sapiens', 'Mus musculus', 'Rattus norvegicus')", sep="\n")
res = dbGetQuery(mydb, sql_orga2)
kable(res)
```

We create a materialized view `BIOQC_RES_FIL` with bioqc results that are filted according 
to these criteria in `db/views/bioqc_res_fil.sql`. Make sure the results are identical: 
```{r test_view, cache=TRUE}
sqlTest = "select /*+ parallel(16) */ count(distinct gsm) from bioqc_res_fil"
resTest = dbGetQuery(mydb, sqlTest)
expect_equal(res$GSM, resTest[1,1])
```


## Tissue selection
Number of samples per tissue:
```{r tissues, cache=TRUE}
sqlTissue = "
select /*+ parallel(16) */ tissue, count(distinct gsm) as samples from bioqc_res_fil
group by tissue
order by samples desc"
resTissue = dbGetQuery(mydb, sqlTissue)
kable(resTissue)
```
